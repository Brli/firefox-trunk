Description: Use GIO for the default browser settings
 This is based on a patch already approved upstream, but the changes
 to nsIGIOService and nsIGIOMimeApp are made in a new interface rather
 than modifying the original interfaces. This is to keep nsIGIOService
 and nsIGIOMimeApp ABI compatible with mozilla.org builds
Author: Chris Coulson <chris.coulson@canonical.com>
Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=611953
Forwarded: https://bug611953.bugzilla.mozilla.org/attachment.cgi?id=503225

--- a/browser/components/shell/src/nsGNOMEShellService.cpp
+++ b/browser/components/shell/src/nsGNOMEShellService.cpp
@@ -106,14 +106,14 @@ nsGNOMEShellService::Init()
 {
   nsresult rv;
 
-  // GConf _must_ be available, or we do not allow
+  // GConf or GIO _must_ be available, or we do not allow
   // CreateInstance to succeed.
 
   nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
   nsCOMPtr<nsIGIOService> giovfs =
     do_GetService(NS_GIOSERVICE_CONTRACTID);
 
-  if (!gconf)
+  if (!gconf && !giovfs)
     return NS_ERROR_NOT_AVAILABLE;
 
   // Check G_BROKEN_FILENAMES.  If it's set, then filenames in glib use
@@ -194,6 +194,27 @@ nsGNOMEShellService::KeyMatchesAppName(c
   return matches;
 }
 
+PRBool
+nsGNOMEShellService::CheckHandlerMatchesAppName(const nsACString &handler) const
+{
+  gint argc;
+  gchar **argv;
+  nsCAutoString command(handler);
+
+  // The string will be something of the form: [/path/to/]browser "%s"
+  // We want to remove all of the parameters and get just the binary name.
+
+  if (g_shell_parse_argv(command.get(), &argc, &argv, NULL) && argc > 0) {
+    command.Assign(argv[0]);
+    g_strfreev(argv);
+  }
+
+  if (!KeyMatchesAppName(command.get()))
+    return PR_FALSE; // the handler is set to another app
+
+  return PR_TRUE;
+}
+
 NS_IMETHODIMP
 nsGNOMEShellService::IsDefaultBrowser(PRBool aStartupCheck,
                                       PRBool* aIsDefaultBrowser)
@@ -203,31 +224,37 @@ nsGNOMEShellService::IsDefaultBrowser(PR
     mCheckedThisSession = PR_TRUE;
 
   nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
+  nsCOMPtr<nsIGIOService_UBUNTU_BRANCH> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
 
   PRBool enabled;
   nsCAutoString handler;
+  nsCOMPtr<nsIGIOMimeApp> gioApp;
 
   for (unsigned int i = 0; i < NS_ARRAY_LENGTH(appProtocols); ++i) {
     if (!appProtocols[i].essential)
       continue;
 
-    handler.Truncate();
-    gconf->GetAppForProtocol(nsDependentCString(appProtocols[i].name),
-                             &enabled, handler);
-
-    // The string will be something of the form: [/path/to/]browser "%s"
-    // We want to remove all of the parameters and get just the binary name.
-
-    gint argc;
-    gchar **argv;
-
-    if (g_shell_parse_argv(handler.get(), &argc, &argv, NULL) && argc > 0) {
-      handler.Assign(argv[0]);
-      g_strfreev(argv);
+    if (gconf) {
+      handler.Truncate();
+      gconf->GetAppForProtocol(nsDependentCString(appProtocols[i].name),
+                               &enabled, handler);
+
+      if (!CheckHandlerMatchesAppName(handler) || !enabled)
+        return NS_OK; // the handler is disabled or set to another app
     }
 
-    if (!KeyMatchesAppName(handler.get()) || !enabled)
-      return NS_OK; // the handler is disabled or set to another app
+    if (giovfs) {
+      handler.Truncate();
+      giovfs->GetAppForURIScheme(nsDependentCString(appProtocols[i].name),
+                                 getter_AddRefs(gioApp));
+      if (!gioApp)
+        return NS_OK;
+
+      gioApp->GetCommand(handler);
+
+      if (!CheckHandlerMatchesAppName(handler))
+        return NS_OK; // the handler is set to another app
+    }
   }
 
   *aIsDefaultBrowser = PR_TRUE;
@@ -245,9 +272,10 @@ nsGNOMEShellService::SetDefaultBrowser(P
 #endif
 
   nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
+  nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
   if (gconf) {
     nsCAutoString appKeyValue;
-    if(mAppIsInPath) {
+    if (mAppIsInPath) {
       // mAppPath is in the users path, so use only the basename as the launcher
       gchar *tmp = g_path_get_basename(mAppPath.get());
       appKeyValue = tmp;
@@ -267,11 +295,8 @@ nsGNOMEShellService::SetDefaultBrowser(P
   }
 
   // set handler for .html and xhtml files and MIME types:
-  if (aClaimAllTypes) {
+  if (giovfs) {
     nsresult rv;
-    nsCOMPtr<nsIGIOService> giovfs =
-      do_GetService(NS_GIOSERVICE_CONTRACTID, &rv);
-    NS_ENSURE_SUCCESS(rv, NS_OK);
 
     nsCOMPtr<nsIStringBundleService> bundleService =
       do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
@@ -295,10 +320,24 @@ nsGNOMEShellService::SetDefaultBrowser(P
                                       getter_AddRefs(appInfo));
     NS_ENSURE_SUCCESS(rv, rv);
 
-    // Add mime types for html, xhtml extension and set app to just created appinfo.
-    for (unsigned int i = 0; i < NS_ARRAY_LENGTH(appTypes); ++i) {
-      appInfo->SetAsDefaultForMimeType(nsDependentCString(appTypes[i].mimeType));
-      appInfo->SetAsDefaultForFileExtensions(nsDependentCString(appTypes[i].extensions));
+    nsCOMPtr<nsIGIOMimeApp_UBUNTU_BRANCH> appInfoUbuntu =
+      do_QueryInterface(appInfo);
+    NS_ENSURE_TRUE(appInfoUbuntu, NS_ERROR_FAILURE);
+
+    // set handler for the protocols
+    for (unsigned int i = 0; i < NS_ARRAY_LENGTH(appProtocols); ++i) {
+      if (appProtocols[i].essential || aClaimAllTypes) {
+        appInfoUbuntu->SetAsDefaultForURIScheme(nsDependentCString(appProtocols[i].name));
+      }
+    }
+
+    // set handler for .html and xhtml files and MIME types:
+    if (aClaimAllTypes) {
+      // Add mime types for html, xhtml extension and set app to just created appinfo.
+      for (unsigned int i = 0; i < NS_ARRAY_LENGTH(appTypes); ++i) {
+        appInfo->SetAsDefaultForMimeType(nsDependentCString(appTypes[i].mimeType));
+        appInfo->SetAsDefaultForFileExtensions(nsDependentCString(appTypes[i].extensions));
+      }
     }
   }
 
@@ -408,24 +447,26 @@ nsGNOMEShellService::SetDesktopBackgroun
   // if the file was written successfully, set it as the system wallpaper
   nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
 
-  nsCAutoString options;
-  if (aPosition == BACKGROUND_TILE)
-    options.Assign("wallpaper");
-  else if (aPosition == BACKGROUND_STRETCH)
-    options.Assign("stretched");
-  else
-    options.Assign("centered");
-
-  gconf->SetString(NS_LITERAL_CSTRING(kDesktopOptionsKey), options);
-
-  // Set the image to an empty string first to force a refresh
-  // (since we could be writing a new image on top of an existing
-  // Firefox_wallpaper.png and nautilus doesn't monitor the file for changes)
-  gconf->SetString(NS_LITERAL_CSTRING(kDesktopImageKey),
-                   EmptyCString());
+  if (gconf) {
+    nsCAutoString options;
+    if (aPosition == BACKGROUND_TILE)
+      options.Assign("wallpaper");
+    else if (aPosition == BACKGROUND_STRETCH)
+      options.Assign("stretched");
+    else
+      options.Assign("centered");
+
+    gconf->SetString(NS_LITERAL_CSTRING(kDesktopOptionsKey), options);
+
+    // Set the image to an empty string first to force a refresh
+    // (since we could be writing a new image on top of an existing
+    // Firefox_wallpaper.png and nautilus doesn't monitor the file for changes)
+    gconf->SetString(NS_LITERAL_CSTRING(kDesktopImageKey),
+                     EmptyCString());
 
-  gconf->SetString(NS_LITERAL_CSTRING(kDesktopImageKey), filePath);
-  gconf->SetBool(NS_LITERAL_CSTRING(kDesktopDrawBGKey), PR_TRUE);
+    gconf->SetString(NS_LITERAL_CSTRING(kDesktopImageKey), filePath);
+    gconf->SetBool(NS_LITERAL_CSTRING(kDesktopDrawBGKey), PR_TRUE);
+  }
 
   return rv;
 }
@@ -439,7 +480,9 @@ nsGNOMEShellService::GetDesktopBackgroun
   nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
 
   nsCAutoString background;
-  gconf->GetString(NS_LITERAL_CSTRING(kDesktopColorKey), background);
+  if (gconf) {
+    gconf->GetString(NS_LITERAL_CSTRING(kDesktopColorKey), background);
+  }
 
   if (background.IsEmpty()) {
     *aColor = 0;
@@ -478,10 +521,12 @@ nsGNOMEShellService::SetDesktopBackgroun
   NS_ASSERTION(aColor <= 0xffffff, "aColor has extra bits");
   nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
 
-  nsCAutoString colorString;
-  ColorToCString(aColor, colorString);
+  if (gconf) {
+    nsCAutoString colorString;
+    ColorToCString(aColor, colorString);
 
-  gconf->SetString(NS_LITERAL_CSTRING(kDesktopColorKey), colorString);
+    gconf->SetString(NS_LITERAL_CSTRING(kDesktopColorKey), colorString);
+  }
 
   return NS_OK;
 }
@@ -497,7 +542,17 @@ nsGNOMEShellService::OpenApplication(PRI
   else
     return NS_ERROR_NOT_AVAILABLE;
 
+  nsCOMPtr<nsIGIOService_UBUNTU_BRANCH> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
+  if (giovfs) {
+    nsCOMPtr<nsIGIOMimeApp> gioApp;
+    giovfs->GetAppForURIScheme(scheme, getter_AddRefs(gioApp));
+    if (gioApp)
+      return gioApp->Launch(EmptyCString());
+  }
+
   nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
+  if (!gconf)
+    return NS_ERROR_FAILURE;
 
   PRBool enabled;
   nsCAutoString appCommand;
--- a/browser/components/shell/src/nsGNOMEShellService.h
+++ b/browser/components/shell/src/nsGNOMEShellService.h
@@ -54,6 +54,7 @@ private:
   ~nsGNOMEShellService() {}
 
   NS_HIDDEN_(PRBool) KeyMatchesAppName(const char *aKeyValue) const;
+  NS_HIDDEN_(PRBool) CheckHandlerMatchesAppName(const nsACString& handler) const;
 
   NS_HIDDEN_(PRBool) GetAppPathFromLauncher();
   PRPackedBool mCheckedThisSession;
--- a/toolkit/system/gnome/nsGIOService.cpp
+++ b/toolkit/system/gnome/nsGIOService.cpp
@@ -72,11 +72,13 @@ get_content_type_from_mime_type(const ch
   return foundContentType;
 }
 
-class nsGIOMimeApp : public nsIGIOMimeApp
+class nsGIOMimeApp : public nsIGIOMimeApp,
+                     public nsIGIOMimeApp_UBUNTU_BRANCH
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIGIOMIMEAPP
+  NS_DECL_NSIGIOMIMEAPP_UBUNTU_BRANCH
 
   nsGIOMimeApp(GAppInfo* aApp) : mApp(aApp) {}
   ~nsGIOMimeApp() { g_object_unref(mApp); }
@@ -85,7 +87,7 @@ private:
   GAppInfo *mApp;
 };
 
-NS_IMPL_ISUPPORTS1(nsGIOMimeApp, nsIGIOMimeApp)
+NS_IMPL_ISUPPORTS2(nsGIOMimeApp, nsIGIOMimeApp, nsIGIOMimeApp_UBUNTU_BRANCH)
 
 NS_IMETHODIMP
 nsGIOMimeApp::GetId(nsACString& aId)
@@ -282,6 +284,33 @@ nsGIOMimeApp::SetAsDefaultForFileExtensi
   return NS_OK;
 }
 
+/**
+ * Set default application for URI's of a particular scheme
+ * @param aURIScheme string containing the URI scheme
+ * @return NS_OK when application was set as default for URI scheme,
+ * NS_ERROR_FAILURE otherwise
+ */
+NS_IMETHODIMP
+nsGIOMimeApp::SetAsDefaultForURIScheme(nsACString const& aURIScheme)
+{
+  GError *error = NULL;
+  nsCAutoString contentType("x-scheme-handler/");
+  contentType.Append(aURIScheme);
+
+  g_app_info_set_as_default_for_type(mApp,
+                                     contentType.get(),
+                                     &error);
+  if (error) {
+    g_warning("Cannot set application as default for URI scheme (%s): %s",
+              PromiseFlatCString(aURIScheme).get(),
+              error->message);
+    g_error_free(error);
+    return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+}
+
 nsresult
 nsGIOService::Init()
 {
@@ -289,7 +318,7 @@ nsGIOService::Init()
   return NS_OK;
 }
 
-NS_IMPL_ISUPPORTS1(nsGIOService, nsIGIOService)
+NS_IMPL_ISUPPORTS2(nsGIOService, nsIGIOService, nsIGIOService_UBUNTU_BRANCH)
 
 NS_IMETHODIMP
 nsGIOService::GetMimeTypeFromExtension(const nsACString& aExtension,
@@ -322,6 +351,23 @@ nsGIOService::GetMimeTypeFromExtension(c
 // used in nsGNOMERegistry
 // -----------------------------------------------------------------------------
 NS_IMETHODIMP
+nsGIOService::GetAppForURIScheme(const nsACString& aURIScheme,
+                                 nsIGIOMimeApp** aApp)
+{
+  *aApp = nsnull;
+
+  GAppInfo *app_info = g_app_info_get_default_for_uri_scheme(
+                          PromiseFlatCString(aURIScheme).get());
+  if (app_info) {
+    nsGIOMimeApp *mozApp = new nsGIOMimeApp(app_info);
+    NS_ADDREF(*aApp = mozApp);
+  } else {
+    return NS_ERROR_FAILURE;
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsGIOService::GetAppForMimeType(const nsACString& aMimeType,
                                 nsIGIOMimeApp**   aApp)
 {
--- a/xpcom/system/nsIGIOService.idl
+++ b/xpcom/system/nsIGIOService.idl
@@ -104,6 +104,19 @@ interface nsIGIOService : nsISupports
   [noscript] void    showURIForInput(in ACString uri);
 };
 
+[scriptable, uuid(5bb1ec9e-30e3-4a4d-9d19-fd0d6033e899)]
+interface nsIGIOMimeApp_UBUNTU_BRANCH : nsISupports
+{
+  void setAsDefaultForURIScheme(in AUTF8String uriScheme);
+};
+
+[scriptable, uuid(59b700c8-8258-4d57-989a-5780fe47df3f)]
+interface nsIGIOService_UBUNTU_BRANCH : nsISupports
+{
+  /* Obtain the preferred application for opening a given URI scheme */
+  nsIGIOMimeApp      getAppForURIScheme(in AUTF8String aURIScheme);
+};
+
 %{C++
 #define NS_GIOSERVICE_CONTRACTID "@mozilla.org/gio-service;1"
 %}
--- a/toolkit/system/gnome/nsGIOService.h
+++ b/toolkit/system/gnome/nsGIOService.h
@@ -44,11 +44,13 @@
 #define NS_GIOSERVICE_CID \
 {0xe3a1f3c9, 0x3ae1, 0x4b40, {0xa5, 0xe0, 0x7b, 0x45, 0x7f, 0xc9, 0xa9, 0xad}}
 
-class nsGIOService : public nsIGIOService
+class nsGIOService : public nsIGIOService,
+                     public nsIGIOService_UBUNTU_BRANCH
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIGIOSERVICE
+  NS_DECL_NSIGIOSERVICE_UBUNTU_BRANCH
 
   NS_HIDDEN_(nsresult) Init();
 };

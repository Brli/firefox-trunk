Description: Add KDE integration to Firefox (toolkit parts)
Author: Wolfgang Rosenauer <wolfgang@rosenauer.org>
Author: Felix Geyer <debfx-pkg@fobos.de>
Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=140751
Bug-Ubuntu: https://launchpad.net/bugs/494067
Bug-OpenSUSE: https://bugzilla.novell.com/show_bug.cgi?id=170055
Forwarded: no

diff --git a/modules/libpref/src/Makefile.in b/modules/libpref/src/Makefile.in
--- a/modules/libpref/src/Makefile.in
+++ b/modules/libpref/src/Makefile.in
@@ -77,14 +77,16 @@ GREPREF_FILES = $(topsrcdir)/netwerk/bas
 # Optimizer bug with GCC 3.2.2 on OS/2
 ifeq ($(OS_ARCH), OS2)
 nsPrefService.$(OBJ_SUFFIX): nsPrefService.cpp
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CXX)
 	$(ELOG) $(CCC) $(OUTOPTION)$@ -c $(COMPILE_CXXFLAGS:-O2=-O1) $(_VPATH_SRCS)
 endif
 
+LOCAL_INCLUDES += -I$(topsrcdir)/toolkit/xre
+
 
 greprefs.js: $(GREPREF_FILES)
 	$(PYTHON) $(topsrcdir)/config/Preprocessor.py $(PREF_PPFLAGS) $(DEFINES) $(ACDEFINES) $(XULPPFLAGS) $^ > $@
 
 libs:: greprefs.js
 	$(INSTALL) $^ $(DIST)/bin/
diff --git a/toolkit/components/downloads/Makefile.in b/toolkit/components/downloads/Makefile.in
--- a/toolkit/components/downloads/Makefile.in
+++ b/toolkit/components/downloads/Makefile.in
@@ -75,8 +75,10 @@ EXTRA_COMPONENTS = \
   $(NULL)
 endif
 
 ifdef ENABLE_TESTS
 DIRS += test
 endif
 
 include $(topsrcdir)/config/rules.mk
+
+LOCAL_INCLUDES += -I$(topsrcdir)/toolkit/xre
diff --git a/toolkit/components/downloads/nsDownloadManager.cpp b/toolkit/components/downloads/nsDownloadManager.cpp
--- a/toolkit/components/downloads/nsDownloadManager.cpp
+++ b/toolkit/components/downloads/nsDownloadManager.cpp
@@ -74,16 +74,20 @@
 
 #ifdef XP_WIN
 #include <shlobj.h>
 #ifdef DOWNLOAD_SCANNER
 #include "nsDownloadScanner.h"
 #endif
 #endif
 
+#if defined(XP_UNIX) && !defined(XP_MACOSX)
+#include "nsKDEUtils.h"
+#endif
+
 #ifdef XP_MACOSX
 #include <CoreFoundation/CoreFoundation.h>
 #endif
 
 #ifdef MOZ_WIDGET_ANDROID
 #include "AndroidBridge.h"
 #endif
 
@@ -2218,16 +2222,25 @@ nsDownload::SetState(DownloadState aStat
       nsCOMPtr<nsIPrefBranch> pref(do_GetService(NS_PREFSERVICE_CONTRACTID));
 
       // Master pref to control this function.
       bool showTaskbarAlert = true;
       if (pref)
         pref->GetBoolPref(PREF_BDM_SHOWALERTONCOMPLETE, &showTaskbarAlert);
 
       if (showTaskbarAlert) {
+        if( nsKDEUtils::kdeSupport()) {
+            nsTArray<nsCString> command;
+            command.AppendElement( NS_LITERAL_CSTRING( "DOWNLOADFINISHED" ));
+            nsAutoString displayName;
+            GetDisplayName( displayName );
+            command.AppendElement( nsCAutoString( ToNewUTF8String( displayName )));
+            nsKDEUtils::command( command );
+        } else {
+        // begin non-KDE block
         PRInt32 alertInterval = 2000;
         if (pref)
           pref->GetIntPref(PREF_BDM_SHOWALERTINTERVAL, &alertInterval);
 
         PRInt64 alertIntervalUSec = alertInterval * PR_USEC_PER_MSEC;
         PRInt64 goat = PR_Now() - mStartTime;
         showTaskbarAlert = goat > alertIntervalUSec;
 
@@ -2253,16 +2266,17 @@ nsDownload::SetState(DownloadState aStat
               // because if it is, they'll click open the download manager and
               // the items they downloaded will have been removed.
               alerts->ShowAlertNotification(
                   NS_LITERAL_STRING(DOWNLOAD_MANAGER_ALERT_ICON), title,
                   message, !removeWhenDone, EmptyString(), mDownloadManager,
                   EmptyString());
             }
         }
+        } // end non-KDE block
       }
 
 #if defined(XP_WIN) || defined(XP_MACOSX) || defined(MOZ_WIDGET_ANDROID)
       nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(mTarget);
       nsCOMPtr<nsIFile> file;
       nsAutoString path;
 
       if (fileURL &&
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -40,29 +40,33 @@ toolkit.jar:
 *+ content/global/viewZoomOverlay.js          (viewZoomOverlay.js)
 *+ content/global/bindings/autocomplete.xml    (widgets/autocomplete.xml)
 *+ content/global/bindings/browser.xml         (widgets/browser.xml)
 *+ content/global/bindings/button.xml          (widgets/button.xml)
 *+ content/global/bindings/checkbox.xml        (widgets/checkbox.xml)
 *+ content/global/bindings/colorpicker.xml     (widgets/colorpicker.xml)
 *+ content/global/bindings/datetimepicker.xml  (widgets/datetimepicker.xml)
 *+ content/global/bindings/dialog.xml          (widgets/dialog.xml)
+*+ content/global/bindings/dialog-kde.xml      (widgets/dialog-kde.xml)
+% override chrome://global/content/bindings/dialog.xml chrome://global/content/bindings/dialog-kde.xml desktop=kde
 *+ content/global/bindings/editor.xml          (widgets/editor.xml)
 *  content/global/bindings/expander.xml        (widgets/expander.xml)
 *  content/global/bindings/filefield.xml       (widgets/filefield.xml)
 *+ content/global/bindings/findbar.xml         (widgets/findbar.xml)
 *+ content/global/bindings/general.xml         (widgets/general.xml)
 *+ content/global/bindings/groupbox.xml        (widgets/groupbox.xml)
 *+ content/global/bindings/listbox.xml         (widgets/listbox.xml)
 *+ content/global/bindings/menu.xml            (widgets/menu.xml)
 *+ content/global/bindings/menulist.xml        (widgets/menulist.xml)
 *+ content/global/bindings/notification.xml    (widgets/notification.xml)
 *+ content/global/bindings/numberbox.xml       (widgets/numberbox.xml)
 *+ content/global/bindings/popup.xml           (widgets/popup.xml)
 *+ content/global/bindings/preferences.xml     (widgets/preferences.xml)
+*+ content/global/bindings/preferences-kde.xml (widgets/preferences-kde.xml)
+% override chrome://global/content/bindings/preferences.xml chrome://global/content/bindings/preferences-kde.xml desktop=kde
 *+ content/global/bindings/progressmeter.xml   (widgets/progressmeter.xml)
 *+ content/global/bindings/radio.xml           (widgets/radio.xml)
 *+ content/global/bindings/resizer.xml         (widgets/resizer.xml)
 *+ content/global/bindings/richlistbox.xml     (widgets/richlistbox.xml)
 *+ content/global/bindings/scale.xml           (widgets/scale.xml)
 *+ content/global/bindings/scrollbar.xml       (widgets/scrollbar.xml)
 *+ content/global/bindings/scrollbox.xml       (widgets/scrollbox.xml)
 *+ content/global/bindings/splitter.xml        (widgets/splitter.xml)
diff --git a/toolkit/content/widgets/dialog-kde.xml b/toolkit/content/widgets/dialog-kde.xml
--- a/toolkit/content/widgets/dialog-kde.xml
+++ b/toolkit/content/widgets/dialog-kde.xml
@@ -11,25 +11,34 @@
     </resources>
     <content>
       <xul:vbox class="box-inherit dialog-content-box" flex="1">
         <children/>
       </xul:vbox>
           
       <xul:hbox class="dialog-button-box" anonid="buttons"
                 xbl:inherits="pack=buttonpack,align=buttonalign,dir=buttondir,orient=buttonorient"
-#ifdef XP_UNIX
+#ifdef XP_UNIX_GNOME
                 >
         <xul:button dlgtype="disclosure" class="dialog-button" hidden="true"/>
         <xul:button dlgtype="help" class="dialog-button" hidden="true"/>
         <xul:button dlgtype="extra2" class="dialog-button" hidden="true"/>
         <xul:button dlgtype="extra1" class="dialog-button" hidden="true"/>
         <xul:spacer anonid="spacer" flex="1"/>
         <xul:button dlgtype="cancel" class="dialog-button"/>
         <xul:button dlgtype="accept" class="dialog-button" xbl:inherits="disabled=buttondisabledaccept"/>
+#elif XP_UNIX
+                pack="end">
+	<xul:button dlgtype="help" class="dialog-button" hidden="true"/>
+	<xul:button dlgtype="extra2" class="dialog-button" hidden="true"/>
+	<xul:spacer anonid="spacer" flex="1" hidden="true"/>
+	<xul:button dlgtype="accept" class="dialog-button" xbl:inherits="disabled=buttondisabledaccept"/>
+	<xul:button dlgtype="extra1" class="dialog-button" hidden="true"/>
+	<xul:button dlgtype="cancel" class="dialog-button"/>
+	<xul:button dlgtype="disclosure" class="dialog-button" hidden="true"/>
 #else
                 pack="end">
         <xul:button dlgtype="extra2" class="dialog-button" hidden="true"/>
         <xul:spacer anonid="spacer" flex="1" hidden="true"/>
         <xul:button dlgtype="accept" class="dialog-button" xbl:inherits="disabled=buttondisabledaccept"/>
         <xul:button dlgtype="extra1" class="dialog-button" hidden="true"/>
         <xul:button dlgtype="cancel" class="dialog-button"/>
         <xul:button dlgtype="help" class="dialog-button" hidden="true"/>
diff --git a/toolkit/content/widgets/preferences-kde.xml b/toolkit/content/widgets/preferences-kde.xml
--- a/toolkit/content/widgets/preferences-kde.xml
+++ b/toolkit/content/widgets/preferences-kde.xml
@@ -568,25 +568,34 @@
                         role="listbox"/> <!-- Expose to accessibility APIs as a listbox -->
       </xul:windowdragbox>
       <xul:hbox flex="1" class="paneDeckContainer">
         <xul:deck anonid="paneDeck" flex="1">
           <children includes="prefpane"/>
         </xul:deck>
       </xul:hbox>
       <xul:hbox anonid="dlg-buttons" class="prefWindow-dlgbuttons"
-#ifdef XP_UNIX
+#ifdef XP_UNIX_GNOME
                 >
         <xul:button dlgtype="disclosure" class="dialog-button" hidden="true"/>
         <xul:button dlgtype="help" class="dialog-button" hidden="true" icon="help"/>
         <xul:button dlgtype="extra2" class="dialog-button" hidden="true"/>
         <xul:button dlgtype="extra1" class="dialog-button" hidden="true"/>
         <xul:spacer anonid="spacer" flex="1"/>
         <xul:button dlgtype="cancel" class="dialog-button" icon="cancel"/>
         <xul:button dlgtype="accept" class="dialog-button" icon="accept"/>
+#elif XP_UNIX
+                pack="end">
+	<xul:button dlgtype="help" class="dialog-button" hidden="true" icon="help"/>
+	<xul:button dlgtype="extra2" class="dialog-button" hidden="true"/>
+	<xul:spacer anonid="spacer" flex="1"/>
+	<xul:button dlgtype="accept" class="dialog-button" icon="accept"/>
+	<xul:button dlgtype="extra1" class="dialog-button" hidden="true"/>
+	<xul:button dlgtype="cancel" class="dialog-button" icon="cancel"/>
+	<xul:button dlgtype="disclosure" class="dialog-button" hidden="true"/>
 #else
                 pack="end">
         <xul:button dlgtype="extra2" class="dialog-button" hidden="true"/>
         <xul:spacer anonid="spacer" flex="1"/>
         <xul:button dlgtype="accept" class="dialog-button" icon="accept"/>
         <xul:button dlgtype="extra1" class="dialog-button" hidden="true"/>
         <xul:button dlgtype="cancel" class="dialog-button" icon="cancel"/>
         <xul:button dlgtype="help" class="dialog-button" hidden="true" icon="help"/>
diff --git a/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp b/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp
--- a/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp
+++ b/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp
@@ -45,16 +45,17 @@
 #include "nsReadableUtils.h"
 #include "nsArrayUtils.h"
 #include "prnetdb.h"
 #include "prenv.h"
 #include "nsPrintfCString.h"
 #include "nsNetUtil.h"
 #include "nsISupportsPrimitives.h"
 #include "nsIGSettingsService.h"
+#include "nsKDEUtils.h"
 
 class nsUnixSystemProxySettings : public nsISystemProxySettings {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSISYSTEMPROXYSETTINGS
 
   nsUnixSystemProxySettings() {}
   nsresult Init();
@@ -64,16 +65,17 @@ private:
   
   nsCOMPtr<nsIGConfService> mGConf;
   nsCOMPtr<nsIGSettingsService> mGSettings;
   bool IsProxyMode(const char* aMode);
   nsresult SetProxyResultFromGConf(const char* aKeyBase, const char* aType, nsACString& aResult);
   nsresult GetProxyFromGConf(const nsACString& aScheme, const nsACString& aHost, PRInt32 aPort, nsACString& aResult);
   nsresult GetProxyFromGSettings(const nsACString& aScheme, const nsACString& aHost, PRInt32 aPort, nsACString& aResult);
   nsresult SetProxyResultFromGSettings(const char* aKeyBase, const char* aType, nsACString& aResult);
+  nsresult GetProxyFromKDE(const nsACString& aScheme, const nsACString& aHost, PRInt32 aPort, nsACString& aResult);
 };
 
 NS_IMPL_ISUPPORTS1(nsUnixSystemProxySettings, nsISystemProxySettings)
 
 nsresult
 nsUnixSystemProxySettings::Init()
 {
   mGConf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
@@ -521,27 +523,54 @@ nsUnixSystemProxySettings::GetProxyForUR
   nsCAutoString host;
   rv = aURI->GetHost(host);
   NS_ENSURE_SUCCESS(rv, rv);
 
   PRInt32 port;
   rv = aURI->GetPort(&port);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  if (nsKDEUtils::kdeSupport())
+    return GetProxyFromKDE(scheme, host, port, aResult);
+
   if (mGSettings) {
     rv = GetProxyFromGSettings(scheme, host, port, aResult);
     if (rv == NS_OK)
       return rv;
   }
   if (mGConf)
     return GetProxyFromGConf(scheme, host, port, aResult);
 
   return GetProxyFromEnvironment(scheme, host, port, aResult);
 }
 
+nsresult
+nsUnixSystemProxySettings::GetProxyFromKDE(const nsACString& aScheme,
+                                           const nsACString& aHost,
+                                           PRInt32 aPort,
+                                           nsACString& aResult)
+{
+  nsCAutoString url;
+  url = aScheme;
+  url += "://";
+  url += aHost;
+  if (aPort >= 0){
+    url += ":";
+    url += nsPrintfCString("%d", aPort);
+  }
+  nsTArray<nsCString> command;
+  command.AppendElement(NS_LITERAL_CSTRING("GETPROXY"));
+  command.AppendElement(url);
+  nsTArray<nsCString> result;
+  if (!nsKDEUtils::command(command, &result) || result.Length() != 1)
+    return NS_ERROR_FAILURE;
+  aResult = result[0];
+  return NS_OK;
+}
+
 #define NS_UNIXSYSTEMPROXYSERVICE_CID  /* 0fa3158c-d5a7-43de-9181-a285e74cf1d4 */\
      { 0x0fa3158c, 0xd5a7, 0x43de, \
        {0x91, 0x81, 0xa2, 0x85, 0xe7, 0x4c, 0xf1, 0xd4 } }
 
 NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsUnixSystemProxySettings, Init)
 NS_DEFINE_NAMED_CID(NS_UNIXSYSTEMPROXYSERVICE_CID);
 
 static const mozilla::Module::CIDEntry kUnixProxyCIDs[] = {
diff --git a/toolkit/xre/Makefile.in b/toolkit/xre/Makefile.in
--- a/toolkit/xre/Makefile.in
+++ b/toolkit/xre/Makefile.in
@@ -96,17 +96,18 @@ else
 ifeq ($(MOZ_WIDGET_TOOLKIT),cocoa)
 CMMSRCS = nsNativeAppSupportCocoa.mm
 EXPORTS += MacQuirks.h
 else
 ifeq ($(MOZ_WIDGET_TOOLKIT),os2)
 CPPSRCS += nsNativeAppSupportOS2.cpp
 else
 ifeq ($(MOZ_WIDGET_TOOLKIT),gtk2)
-CPPSRCS += nsNativeAppSupportUnix.cpp
+CPPSRCS += nsNativeAppSupportUnix.cpp nsKDEUtils.cpp
+EXPORTS += nsKDEUtils.h
 else
 ifeq ($(MOZ_WIDGET_TOOLKIT),qt)
 MOCSRCS += moc_nsNativeAppSupportQt.cpp
 CPPSRCS += $(MOCSRCS)
 CPPSRCS += nsNativeAppSupportQt.cpp
 CPPSRCS += nsQAppInstance.cpp
 EXPORTS += nsQAppInstance.h
 else
diff --git a/toolkit/xre/nsKDEUtils.cpp b/toolkit/xre/nsKDEUtils.cpp
new file mode 100644
--- /dev/null
+++ b/toolkit/xre/nsKDEUtils.cpp
@@ -0,0 +1,377 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Unix Native App Support.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsKDEUtils.h"
+#include "nsIWidget.h"
+#include "nsISupportsPrimitives.h"
+#include "nsIMutableArray.h"
+#include "nsComponentManagerUtils.h"
+#include "nsArrayUtils.h"
+
+#include <gtk/gtk.h>
+
+#include <limits.h>
+#include <stdio.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#include <X11/Xlib.h>
+
+//#define DEBUG_KDE
+#ifdef DEBUG_KDE
+#define KMOZILLAHELPER "kmozillahelper"
+#else
+// not need for lib64, it's a binary
+#define KMOZILLAHELPER "/usr/lib/mozilla/kmozillahelper"
+#endif
+
+#define KMOZILLAHELPER_VERSION 6
+#define MAKE_STR2( n ) #n
+#define MAKE_STR( n ) MAKE_STR2( n )
+
+static bool getKdeSession()
+    {
+    Display* dpy = XOpenDisplay( NULL );
+    if( dpy == NULL )
+        return false;
+    Atom kde_full_session = XInternAtom( dpy, "KDE_FULL_SESSION", True );
+    bool kde = false;
+    if( kde_full_session != None )
+        {
+        int cnt;
+        if( Atom* props = XListProperties( dpy, DefaultRootWindow( dpy ), &cnt ))
+            {
+            for( int i = 0;
+                 i < cnt;
+                 ++i )
+                {
+                if( props[ i ] == kde_full_session )
+                    {
+                    kde = true;
+#ifdef DEBUG_KDE
+                    fprintf( stderr, "KDE SESSION %d\n", kde );
+#endif
+                    break;
+                    }
+                }
+            XFree( props );
+            }
+        }
+    XCloseDisplay( dpy );
+    return kde;
+    }
+
+static bool getKdeSupport()
+    {
+    nsTArray<nsCString> command;
+    command.AppendElement( NS_LITERAL_CSTRING( "CHECK" ));
+    command.AppendElement( NS_LITERAL_CSTRING( MAKE_STR( KMOZILLAHELPER_VERSION )));
+    bool kde = nsKDEUtils::command( command );
+#ifdef DEBUG_KDE
+    fprintf( stderr, "KDE RUNNING %d\n", kde );
+#endif
+    return kde;
+    }
+
+nsKDEUtils::nsKDEUtils()
+    : commandFile( NULL )
+    , replyFile( NULL )
+    {
+    }
+
+nsKDEUtils::~nsKDEUtils()
+    {
+//    closeHelper(); not actually useful, exiting will close the fd too
+    }
+
+nsKDEUtils* nsKDEUtils::self()
+    {
+    static nsKDEUtils s;
+    return &s;
+    }
+
+static bool helperRunning = false;
+static bool helperFailed = false;
+
+bool nsKDEUtils::kdeSession()
+    {
+    static bool session = getKdeSession();
+    return session;
+    }
+
+bool nsKDEUtils::kdeSupport()
+    {
+    static bool support = kdeSession() && getKdeSupport();
+    return support && helperRunning;
+    }
+
+struct nsKDECommandData
+    {
+    FILE* file;
+    nsTArray<nsCString>* output;
+    GMainLoop* loop;
+    bool success;
+    };
+
+static gboolean kdeReadFunc( GIOChannel*, GIOCondition, gpointer data )
+    {
+    nsKDECommandData* p = static_cast< nsKDECommandData* >( data );
+    char buf[ 8192 ]; // TODO big enough
+    bool command_done = false;
+    bool command_failed = false;
+    while( !command_done && !command_failed && fgets( buf, 8192, p->file ) != NULL )
+        { // TODO what if the kernel splits a line into two chunks?
+//#ifdef DEBUG_KDE
+//        fprintf( stderr, "READ: %s %d\n", buf, feof( p->file ));
+//#endif
+        if( char* eol = strchr( buf, '\n' ))
+            *eol = '\0';
+        command_done = ( strcmp( buf, "\\1" ) == 0 );
+        command_failed = ( strcmp( buf, "\\0" ) == 0 );
+        nsCAutoString line( buf );
+        line.ReplaceSubstring( "\\n", "\n" );
+        line.ReplaceSubstring( "\\" "\\", "\\" ); //  \\ -> \ , i.e. unescape
+        if( p->output && !( command_done || command_failed ))
+            p->output->AppendElement( nsCString( buf )); // TODO utf8?
+        }
+    bool quit = false;
+    if( feof( p->file ) || command_failed )
+        {
+        quit = true;
+        p->success = false;
+        }
+    if( command_done )
+        { // reading one reply finished
+        quit = true;
+        p->success = true;
+        }
+    if( quit )
+        {
+        if( p->loop )
+            g_main_loop_quit( p->loop );
+        return FALSE;
+        }
+    return TRUE;
+    }
+
+bool nsKDEUtils::command( const nsTArray<nsCString>& command, nsTArray<nsCString>* output )
+    {
+    return self()->internalCommand( command, NULL, false, output );
+    }
+
+bool nsKDEUtils::command( nsIArray* command, nsIArray** output)
+    {
+    NS_ENSURE_ARG( command );
+
+    nsTArray<nsCString> in;
+    PRUint32 length;
+    command->GetLength( &length );
+    for ( PRUint32 i = 0; i < length; i++ )
+        {
+        nsCOMPtr<nsISupportsCString> str = do_QueryElementAt( command, i );
+        if( str )
+            {
+            nsCAutoString s;
+            str->GetData( s );
+            in.AppendElement( s );
+            }
+        }
+
+    nsTArray<nsCString> out;
+    bool ret = self()->internalCommand( in, NULL, false, &out );
+
+    if ( !output ) return ret;
+
+    nsCOMPtr<nsIMutableArray> result = do_CreateInstance( NS_ARRAY_CONTRACTID );
+    if ( !result ) return false;
+
+    for ( PRUint32 i = 0; i < out.Length(); i++ )
+        {
+        nsCOMPtr<nsISupportsCString> rstr = do_CreateInstance( NS_SUPPORTS_CSTRING_CONTRACTID );
+        if ( !rstr ) return false;
+
+        rstr->SetData( out[i] );
+        result->AppendElement( rstr, false );
+        }
+
+    NS_ADDREF( *output = result);
+    return ret;
+    }
+
+bool nsKDEUtils::commandBlockUi( const nsTArray<nsCString>& command, const GtkWindow* parent, nsTArray<nsCString>* output )
+    {
+    return self()->internalCommand( command, parent, true, output );
+    }
+
+bool nsKDEUtils::internalCommand( const nsTArray<nsCString>& command, const GtkWindow* parent, bool blockUi,
+    nsTArray<nsCString>* output )
+    {
+    if( !startHelper())
+        return false;
+    // if Gtk has meanwhile gotten a grab (bnc#555202, somehow the file dialog
+    // is called with a delay), then do not do anything, as this app would keep
+    // the grabs but block waiting for the helper, which would be unable to do
+    // anything because of the grab
+    if( blockUi && gdk_pointer_is_grabbed())
+        return false;
+    feedCommand( command );
+    // do not store the data in 'this' but in extra structure, just in case there
+    // is reentrancy (can there be? the event loop is re-entered)
+    nsKDECommandData data;
+    data.file = replyFile;
+    data.output = output;
+    data.success = false;
+    if( blockUi )
+        {
+        data.loop = g_main_loop_new( NULL, FALSE );
+        GtkWidget* window = gtk_window_new( GTK_WINDOW_TOPLEVEL );
+        if( parent && parent->group )
+            gtk_window_group_add_window( parent->group, GTK_WINDOW( window ));
+        gtk_widget_realize( window );
+        gtk_widget_set_sensitive( window, TRUE );
+        gtk_grab_add( window );
+        GIOChannel* channel = g_io_channel_unix_new( fileno( data.file ));
+        g_io_add_watch( channel, static_cast< GIOCondition >( G_IO_IN | G_IO_ERR | G_IO_HUP ), kdeReadFunc, &data );
+        g_io_channel_unref( channel );
+        g_main_loop_run( data.loop );
+        g_main_loop_unref( data.loop );
+        gtk_grab_remove( window );
+        gtk_widget_destroy( window );
+        }
+    else
+        {
+        data.loop = NULL;
+        while( kdeReadFunc( NULL, static_cast< GIOCondition >( 0 ), &data ))
+            ;
+        }
+    return data.success;
+    }
+
+bool nsKDEUtils::startHelper()
+    {
+    if( helperRunning )
+        return true;
+    if( helperFailed )
+        return false;
+    helperFailed = true;
+    int fdcommand[ 2 ];
+    int fdreply[ 2 ];
+    if( pipe( fdcommand ) < 0 )
+        return false;
+    if( pipe( fdreply ) < 0 )
+        {
+        close( fdcommand[ 0 ] );
+        close( fdcommand[ 1 ] );
+        return false;
+        }
+    char* args[ 2 ] = { const_cast< char* >( KMOZILLAHELPER ), NULL };
+    switch( fork())
+        {
+        case -1:
+            {
+            close( fdcommand[ 0 ] );
+            close( fdcommand[ 1 ] );
+            close( fdreply[ 0 ] );
+            close( fdreply[ 1 ] );
+            return false;
+            }
+        case 0: // child
+            {
+            if( dup2( fdcommand[ 0 ], STDIN_FILENO ) < 0 )
+                _exit( 1 );
+            if( dup2( fdreply[ 1 ], STDOUT_FILENO ) < 0 )
+                _exit( 1 );
+            int maxfd = 1024; // close all other fds
+            struct rlimit rl;
+            if( getrlimit( RLIMIT_NOFILE, &rl ) == 0 )
+                maxfd = rl.rlim_max;
+            for( int i = 3;
+                 i < maxfd;
+                 ++i )
+                close( i );
+#ifdef DEBUG_KDE
+            execvp( KMOZILLAHELPER, args );
+#else
+            execv( KMOZILLAHELPER, args );
+#endif
+            _exit( 1 ); // failed
+            }
+        default: // parent
+            {
+            commandFile = fdopen( fdcommand[ 1 ], "w" );
+            replyFile = fdopen( fdreply[ 0 ], "r" );
+            close( fdcommand[ 0 ] );
+            close( fdreply[ 1 ] );
+            if( commandFile == NULL || replyFile == NULL )
+                {
+                closeHelper();
+                return false;
+                }
+            // ok, helper ready, getKdeRunning() will check if it works
+            }
+        }
+    helperFailed = false;
+    helperRunning = true;
+    return true;
+    }
+
+void nsKDEUtils::closeHelper()
+    {
+    if( commandFile != NULL )
+        fclose( commandFile ); // this will also make the helper quit
+    if( replyFile != NULL )
+        fclose( replyFile );
+    helperRunning = false;
+    }
+
+void nsKDEUtils::feedCommand( const nsTArray<nsCString>& command )
+    {
+    for( int i = 0;
+         i < command.Length();
+         ++i )
+        {
+        nsCString line = command[ i ];
+        line.ReplaceSubstring( "\\", "\\" "\\" ); // \ -> \\ , i.e. escape
+        line.ReplaceSubstring( "\n", "\\n" );
+#ifdef DEBUG_KDE
+        fprintf( stderr, "COMM: %s\n", line.get());
+#endif
+        fputs( line.get(), commandFile );
+        fputs( "\n", commandFile );
+        }
+    fputs( "\\E\n", commandFile ); // done as \E, so it cannot happen in normal data
+    fflush( commandFile );
+    }
diff --git a/toolkit/xre/nsKDEUtils.h b/toolkit/xre/nsKDEUtils.h
new file mode 100644
--- /dev/null
+++ b/toolkit/xre/nsKDEUtils.h
@@ -0,0 +1,80 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsKDEUtils_h__
+#define nsKDEUtils_h__
+
+#include "nsStringGlue.h"
+#include "nsTArray.h"
+#include <stdio.h>
+
+typedef struct _GtkWindow GtkWindow;
+
+class nsIArray;
+
+class NS_EXPORT nsKDEUtils
+    {
+    public:
+        /* Returns true if running inside a KDE session (regardless of whether there is KDE
+           support available for Firefox). This should be used e.g. when determining
+           dialog button order but not for code that requires the KDE support. */
+        static bool kdeSession();
+        /* Returns true if running inside a KDE session and KDE support is available
+           for Firefox. This should be used everywhere where the external helper is needed. */
+        static bool kdeSupport();
+        /* Executes the given helper command, returns true if helper returned success. */
+        static bool command( const nsTArray<nsCString>& command, nsTArray<nsCString>* output = NULL );
+        static bool command( nsIArray* command, nsIArray** output = NULL );
+        /* Like command(), but additionally blocks the parent widget like if there was
+           a modal dialog shown and enters the event loop (i.e. there are still paint updates,
+           this is for commands that take long). */
+        static bool commandBlockUi( const nsTArray<nsCString>& command, const GtkWindow* parent, nsTArray<nsCString>* output = NULL );
+    private:
+        nsKDEUtils();
+        ~nsKDEUtils();
+        static nsKDEUtils* self();
+        bool startHelper();
+        void closeHelper();
+        void feedCommand( const nsTArray<nsCString>& command );
+        bool internalCommand( const nsTArray<nsCString>& command, const GtkWindow* parent, bool isParent,
+            nsTArray<nsCString>* output );
+        FILE* commandFile;
+        FILE* replyFile;
+    };
+
+#endif // nsKDEUtils
diff --git a/uriloader/exthandler/Makefile.in b/uriloader/exthandler/Makefile.in
--- a/uriloader/exthandler/Makefile.in
+++ b/uriloader/exthandler/Makefile.in
@@ -92,18 +92,19 @@ LOCAL_INCLUDES = -I$(srcdir)
 LOCAL_INCLUDES += -I$(topsrcdir)/dom/base \
             -I$(topsrcdir)/dom/ipc \
             -I$(topsrcdir)/content/base/src \
             -I$(topsrcdir)/content/events/src \
             -I$(topsrcdir)/netwerk/base/src \
             -I$(topsrcdir)/netwerk/protocol/http
 
 ifeq ($(MOZ_WIDGET_TOOLKIT),gtk2)
-OSHELPER	+= nsGNOMERegistry.cpp
+OSHELPER	+= nsCommonRegistry.cpp nsGNOMERegistry.cpp nsKDERegistry.cpp
 OSHELPER  += nsMIMEInfoUnix.cpp
+LOCAL_INCLUDES += -I$(topsrcdir)/toolkit/xre
 endif
 
 ifeq ($(MOZ_WIDGET_TOOLKIT),android)
 OSHELPER += nsMIMEInfoAndroid.cpp
 OSHELPER += nsAndroidHandlerApp.cpp
 OSHELPER += nsExternalSharingAppService.cpp
 EXPORTS += nsExternalSharingAppService.h
 OSHELPER += nsExternalURLHandlerService.cpp
diff --git a/uriloader/exthandler/unix/nsCommonRegistry.cpp b/uriloader/exthandler/unix/nsCommonRegistry.cpp
new file mode 100644
--- /dev/null
+++ b/uriloader/exthandler/unix/nsCommonRegistry.cpp
@@ -0,0 +1,87 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the GNOME helper app implementation.
+ *
+ * The Initial Developer of the Original Code is
+ * IBM Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2003
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Brian Ryner <bryner@brianryner.com>  (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsCommonRegistry.h"
+
+#include "nsGNOMERegistry.h"
+#include "nsKDERegistry.h"
+#include "nsString.h"
+#include "nsVoidArray.h"
+#include "nsKDEUtils.h"
+
+/* static */ bool
+nsCommonRegistry::HandlerExists(const char *aProtocolScheme)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::HandlerExists( aProtocolScheme );
+    return nsGNOMERegistry::HandlerExists( aProtocolScheme );
+}
+
+/* static */ nsresult
+nsCommonRegistry::LoadURL(nsIURI *aURL)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::LoadURL( aURL );
+    return nsGNOMERegistry::LoadURL( aURL );
+}
+
+/* static */ void
+nsCommonRegistry::GetAppDescForScheme(const nsACString& aScheme,
+                                     nsAString& aDesc)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::GetAppDescForScheme( aScheme, aDesc );
+    return nsGNOMERegistry::GetAppDescForScheme( aScheme, aDesc );
+}
+
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsCommonRegistry::GetFromExtension(const nsACString& aFileExt)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::GetFromExtension( aFileExt );
+    return nsGNOMERegistry::GetFromExtension( aFileExt );
+}
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsCommonRegistry::GetFromType(const nsACString& aMIMEType)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::GetFromType( aMIMEType );
+    return nsGNOMERegistry::GetFromType( aMIMEType );
+}
diff --git a/uriloader/exthandler/unix/nsCommonRegistry.h b/uriloader/exthandler/unix/nsCommonRegistry.h
new file mode 100644
--- /dev/null
+++ b/uriloader/exthandler/unix/nsCommonRegistry.h
@@ -0,0 +1,56 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the GNOME helper app implementation.
+ *
+ * The Initial Developer of the Original Code is
+ * IBM Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2003
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Brian Ryner <bryner@brianryner.com>  (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIURI.h"
+#include "nsCOMPtr.h"
+
+class nsMIMEInfoBase;
+
+class nsCommonRegistry
+{
+ public:
+  static bool HandlerExists(const char *aProtocolScheme);
+
+  static nsresult LoadURL(nsIURI *aURL);
+
+  static void GetAppDescForScheme(const nsACString& aScheme,
+                                  nsAString& aDesc);
+
+  static already_AddRefed<nsMIMEInfoBase> GetFromExtension(const nsACString& aFileExt);
+
+  static already_AddRefed<nsMIMEInfoBase> GetFromType(const nsACString& aMIMEType);
+};
diff --git a/uriloader/exthandler/unix/nsKDERegistry.cpp b/uriloader/exthandler/unix/nsKDERegistry.cpp
new file mode 100644
--- /dev/null
+++ b/uriloader/exthandler/unix/nsKDERegistry.cpp
@@ -0,0 +1,119 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the GNOME helper app implementation.
+ *
+ * The Initial Developer of the Original Code is
+ * IBM Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2003
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Brian Ryner <bryner@brianryner.com>  (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsKDERegistry.h"
+#include "prlink.h"
+#include "prmem.h"
+#include "nsString.h"
+#include "nsILocalFile.h"
+#include "nsMIMEInfoUnix.h"
+#include "nsAutoPtr.h"
+#include "nsKDEUtils.h"
+
+/* static */ bool
+nsKDERegistry::HandlerExists(const char *aProtocolScheme)
+{
+    nsTArray<nsCString> command;
+    command.AppendElement( NS_LITERAL_CSTRING( "HANDLEREXISTS" ));
+    command.AppendElement( nsCAutoString( aProtocolScheme ));
+    return nsKDEUtils::command( command );
+}
+
+/* static */ nsresult
+nsKDERegistry::LoadURL(nsIURI *aURL)
+{
+    nsTArray<nsCString> command;
+    command.AppendElement( NS_LITERAL_CSTRING( "OPEN" ));
+    nsCString url;
+    aURL->GetSpec( url );
+    command.AppendElement( url );
+    return nsKDEUtils::command( command );
+}
+
+/* static */ void
+nsKDERegistry::GetAppDescForScheme(const nsACString& aScheme,
+                                     nsAString& aDesc)
+{
+    nsTArray<nsCString> command;
+    command.AppendElement( NS_LITERAL_CSTRING( "GETAPPDESCFORSCHEME" ));
+    command.AppendElement( aScheme );
+    nsTArray<nsCString> output;
+    if( nsKDEUtils::command( command, &output ) && output.Length() == 1 )
+        CopyUTF8toUTF16( output[ 0 ], aDesc );
+}
+
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsKDERegistry::GetFromExtension(const nsACString& aFileExt)
+{
+    NS_ASSERTION(aFileExt[0] != '.', "aFileExt shouldn't start with a dot");
+    nsTArray<nsCString> command;
+    command.AppendElement( NS_LITERAL_CSTRING( "GETFROMEXTENSION" ));
+    command.AppendElement( aFileExt );
+    return GetFromHelper( command );
+}
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsKDERegistry::GetFromType(const nsACString& aMIMEType)
+{
+    nsTArray<nsCString> command;
+    command.AppendElement( NS_LITERAL_CSTRING( "GETFROMTYPE" ));
+    command.AppendElement( aMIMEType );
+    return GetFromHelper( command );
+}
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsKDERegistry::GetFromHelper(const nsTArray<nsCString>& command)
+{
+    nsTArray<nsCString> output;
+    if( nsKDEUtils::command( command, &output ) && output.Length() == 3 )
+        {
+        nsCString mimetype = output[ 0 ];
+        nsRefPtr<nsMIMEInfoUnix> mimeInfo = new nsMIMEInfoUnix( mimetype );
+        NS_ENSURE_TRUE(mimeInfo, nsnull);
+        nsCString description = output[ 1 ];
+        mimeInfo->SetDescription(NS_ConvertUTF8toUTF16(description));
+        nsCString handlerAppName = output[ 2 ];
+        mimeInfo->SetDefaultDescription(NS_ConvertUTF8toUTF16(handlerAppName));
+        mimeInfo->SetPreferredAction(nsIMIMEInfo::useSystemDefault);
+        nsMIMEInfoBase* retval;
+        NS_ADDREF((retval = mimeInfo));
+        return retval;
+        }
+    return nsnull;
+}
diff --git a/uriloader/exthandler/unix/nsKDERegistry.h b/uriloader/exthandler/unix/nsKDERegistry.h
new file mode 100644
--- /dev/null
+++ b/uriloader/exthandler/unix/nsKDERegistry.h
@@ -0,0 +1,62 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the GNOME helper app implementation.
+ *
+ * The Initial Developer of the Original Code is
+ * IBM Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2003
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Brian Ryner <bryner@brianryner.com>  (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIURI.h"
+#include "nsCOMPtr.h"
+#include "nsStringGlue.h"
+#include "nsTArray.h"
+
+class nsMIMEInfoBase;
+class nsCAutoString;
+
+class nsKDERegistry
+{
+ public:
+  static bool HandlerExists(const char *aProtocolScheme);
+
+  static nsresult LoadURL(nsIURI *aURL);
+
+  static void GetAppDescForScheme(const nsACString& aScheme,
+                                  nsAString& aDesc);
+
+  static already_AddRefed<nsMIMEInfoBase> GetFromExtension(const nsACString& aFileExt);
+
+  static already_AddRefed<nsMIMEInfoBase> GetFromType(const nsACString& aMIMEType);
+ private:
+  static already_AddRefed<nsMIMEInfoBase> GetFromHelper(const nsTArray<nsCString>& command);
+
+};
diff --git a/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp b/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp
--- a/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp
+++ b/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp
@@ -50,30 +50,33 @@
 #include <QString>
 #if (MOZ_ENABLE_CONTENTACTION)
 #include <contentaction/contentaction.h>
 #include "nsContentHandlerApp.h"
 #endif
 #endif
 
 #include "nsMIMEInfoUnix.h"
-#include "nsGNOMERegistry.h"
+#include "nsCommonRegistry.h"
 #include "nsIGIOService.h"
 #include "nsNetCID.h"
 #include "nsIIOService.h"
 #include "nsIGnomeVFSService.h"
 #include "nsAutoPtr.h"
 #ifdef MOZ_ENABLE_DBUS
 #include "nsDBusHandlerApp.h"
 #endif
+#if defined(XP_UNIX) && !defined(XP_MACOSX)
+#include "nsKDEUtils.h"
+#endif
 
 nsresult
 nsMIMEInfoUnix::LoadUriInternal(nsIURI * aURI)
 {
-  nsresult rv = nsGNOMERegistry::LoadURL(aURI);
+  nsresult rv = nsCommonRegistry::LoadURL(aURI);
 
 #if (MOZ_PLATFORM_MAEMO == 5) && defined (MOZ_ENABLE_GNOMEVFS)
   if (NS_FAILED(rv)){
     HildonURIAction *action = hildon_uri_get_default_action(mSchemeOrType.get(), nsnull);
     if (action) {
       nsCAutoString spec;
       aURI->GetAsciiSpec(spec);
       if (hildon_uri_open(spec.get(), action, nsnull))
@@ -95,22 +98,22 @@ nsMIMEInfoUnix::LoadUriInternal(nsIURI *
 
   return rv;
 }
 
 NS_IMETHODIMP
 nsMIMEInfoUnix::GetHasDefaultHandler(bool *_retval)
 {
   *_retval = false;
-  nsRefPtr<nsMIMEInfoBase> mimeInfo = nsGNOMERegistry::GetFromType(mSchemeOrType);
+  nsRefPtr<nsMIMEInfoBase> mimeInfo = nsCommonRegistry::GetFromType(mSchemeOrType);
   if (!mimeInfo) {
     nsCAutoString ext;
     nsresult rv = GetPrimaryExtension(ext);
     if (NS_SUCCEEDED(rv)) {
-      mimeInfo = nsGNOMERegistry::GetFromExtension(ext);
+      mimeInfo = nsCommonRegistry::GetFromExtension(ext);
     }
   }
   if (mimeInfo)
     *_retval = true;
 
   if (*_retval)
     return NS_OK;
 
@@ -153,16 +156,33 @@ nsMIMEInfoUnix::LaunchDefaultWithFile(ns
     ContentAction::Action::defaultActionForFile(uri, QString(mSchemeOrType.get()));
   if (action.isValid()) {
     action.trigger();
     return NS_OK;
   }
   return NS_ERROR_FAILURE;
 #endif
 
+  if( nsKDEUtils::kdeSupport()) {
+    bool supports;
+    if( NS_SUCCEEDED( GetHasDefaultHandler( &supports )) && supports ) {
+      nsTArray<nsCString> command;
+      command.AppendElement( NS_LITERAL_CSTRING( "OPEN" ));
+      command.AppendElement( nativePath );
+      command.AppendElement( NS_LITERAL_CSTRING( "MIMETYPE" ));
+      command.AppendElement( mSchemeOrType );
+      if( nsKDEUtils::command( command ))
+        return NS_OK;
+    }
+    if (!mDefaultApplication)
+      return NS_ERROR_FILE_NOT_FOUND;
+
+    return LaunchWithIProcess(mDefaultApplication, nativePath);
+  }
+
   nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
   nsCAutoString uriSpec;
   if (giovfs) {
     // nsGIOMimeApp->Launch wants a URI string instead of local file
     nsresult rv;
     nsCOMPtr<nsIIOService> ioservice = do_GetService(NS_IOSERVICE_CONTRACTID, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     nsCOMPtr<nsIURI> uri;
@@ -180,17 +200,17 @@ nsMIMEInfoUnix::LaunchDefaultWithFile(ns
     /* Fallback to GnomeVFS */
     nsCOMPtr<nsIGnomeVFSMimeApp> app;
     if (NS_SUCCEEDED(gnomevfs->GetAppForMimeType(mSchemeOrType, getter_AddRefs(app))) && app)
       return app->Launch(nativePath);
   }
 
   // If we haven't got an app we try to get a valid one by searching for the
   // extension mapped type
-  nsRefPtr<nsMIMEInfoBase> mimeInfo = nsGNOMERegistry::GetFromExtension(nativePath);
+  nsRefPtr<nsMIMEInfoBase> mimeInfo = nsCommonRegistry::GetFromExtension(nativePath);
   if (mimeInfo) {
     nsCAutoString type;
     mimeInfo->GetType(type);
     if (giovfs) {
       nsCOMPtr<nsIGIOMimeApp> app;
       if (NS_SUCCEEDED(giovfs->GetAppForMimeType(type, getter_AddRefs(app))) && app)
         return app->Launch(uriSpec);
     } else if (gnomevfs) {
diff --git a/uriloader/exthandler/unix/nsOSHelperAppService.cpp b/uriloader/exthandler/unix/nsOSHelperAppService.cpp
--- a/uriloader/exthandler/unix/nsOSHelperAppService.cpp
+++ b/uriloader/exthandler/unix/nsOSHelperAppService.cpp
@@ -44,17 +44,17 @@
 #if defined(MOZ_ENABLE_CONTENTACTION)
 #include <contentaction/contentaction.h>
 #include <QString>
 #endif
 
 #include "nsOSHelperAppService.h"
 #include "nsMIMEInfoUnix.h"
 #ifdef MOZ_WIDGET_GTK2
-#include "nsGNOMERegistry.h"
+#include "nsCommonRegistry.h"
 #endif
 #include "nsISupports.h"
 #include "nsString.h"
 #include "nsReadableUtils.h"
 #include "nsUnicharUtils.h"
 #include "nsXPIDLString.h"
 #include "nsIURL.h"
 #include "nsIFileStreams.h"
@@ -1191,29 +1191,29 @@ nsresult nsOSHelperAppService::OSProtoco
     ContentAction::Action::defaultActionForScheme(QString(aProtocolScheme) + ':');
 
   if (action.isValid())
     *aHandlerExists = true;
 #endif
 
 #ifdef MOZ_WIDGET_GTK2
   // Check the GConf registry for a protocol handler
-  *aHandlerExists = nsGNOMERegistry::HandlerExists(aProtocolScheme);
+  *aHandlerExists = nsCommonRegistry::HandlerExists(aProtocolScheme);
 #if (MOZ_PLATFORM_MAEMO == 5) && defined (MOZ_ENABLE_GNOMEVFS)
   *aHandlerExists = nsMIMEInfoUnix::HandlerExists(aProtocolScheme);
 #endif
 #endif
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsOSHelperAppService::GetApplicationDescription(const nsACString& aScheme, nsAString& _retval)
 {
 #ifdef MOZ_WIDGET_GTK2
-  nsGNOMERegistry::GetAppDescForScheme(aScheme, _retval);
+  nsCommonRegistry::GetAppDescForScheme(aScheme, _retval);
   return _retval.IsEmpty() ? NS_ERROR_NOT_AVAILABLE : NS_OK;
 #else
   return NS_ERROR_NOT_AVAILABLE;
 #endif
 }
 
 nsresult nsOSHelperAppService::GetFileTokenForPath(const PRUnichar * platformAppPath, nsIFile ** aFile)
 {
@@ -1299,17 +1299,17 @@ nsOSHelperAppService::GetFromExtension(c
                                          minorType,
                                          mime_types_description,
                                          true);
 
   if (NS_FAILED(rv) || majorType.IsEmpty()) {
     
 #ifdef MOZ_WIDGET_GTK2
     LOG(("Looking in GNOME registry\n"));
-    nsMIMEInfoBase *gnomeInfo = nsGNOMERegistry::GetFromExtension(aFileExt).get();
+    nsMIMEInfoBase *gnomeInfo = nsCommonRegistry::GetFromExtension(aFileExt).get();
     if (gnomeInfo) {
       LOG(("Got MIMEInfo from GNOME registry\n"));
       return gnomeInfo;
     }
 #endif
 
     rv = LookUpTypeAndDescription(NS_ConvertUTF8toUTF16(aFileExt),
                                   majorType,
@@ -1425,17 +1425,17 @@ nsOSHelperAppService::GetFromType(const 
 #ifdef MOZ_WIDGET_GTK2
   nsMIMEInfoBase *gnomeInfo = nsnull;
   if (handler.IsEmpty()) {
     // No useful data yet.  Check the GNOME registry.  Unfortunately, newer
     // GNOME versions no longer have type-to-extension mappings, so we might
     // get back a MIMEInfo without any extensions set.  In that case we'll have
     // to look in our mime.types files for the extensions.    
     LOG(("Looking in GNOME registry\n"));
-    gnomeInfo = nsGNOMERegistry::GetFromType(aMIMEType).get();
+    gnomeInfo = nsCommonRegistry::GetFromType(aMIMEType).get();
     if (gnomeInfo && gnomeInfo->HasExtensions()) {
       LOG(("Got MIMEInfo from GNOME registry, and it has extensions set\n"));
       return gnomeInfo;
     }
   }
 #endif
 
   // Now look up our extensions
diff --git a/widget/gtk2/Makefile.in b/widget/gtk2/Makefile.in
--- a/widget/gtk2/Makefile.in
+++ b/widget/gtk2/Makefile.in
@@ -135,11 +135,14 @@ DEFINES		+= -DCAIRO_GFX -DMOZ_APP_NAME='
 
 INCLUDES	+= \
 		-I$(srcdir)/../xpwidgets \
 		-I$(srcdir)/../shared \
 		-I$(topsrcdir)/layout/generic \
 		-I$(topsrcdir)/layout/xul/base/src \
 		-I$(topsrcdir)/other-licenses/atk-1.0 \
 		$(NULL)
+
+LOCAL_INCLUDES += -I$(topsrcdir)/toolkit/xre
+
 ifdef MOZ_X11
 INCLUDES   	+= -I$(srcdir)/../shared/x11
 endif
diff --git a/widget/gtk2/nsFilePicker.cpp b/widget/gtk2/nsFilePicker.cpp
--- a/widget/gtk2/nsFilePicker.cpp
+++ b/widget/gtk2/nsFilePicker.cpp
@@ -33,16 +33,17 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "mozilla/Util.h"
 
 #include <gtk/gtk.h>
+#include <gdk/gdkx.h>
 
 #include "nsIFileURL.h"
 #include "nsIURI.h"
 #include "nsIWidget.h"
 #include "nsILocalFile.h"
 #include "nsIStringBundle.h"
 
 #include "nsArrayEnumerator.h"
@@ -51,16 +52,17 @@
 #include "nsNetUtil.h"
 #include "nsReadableUtils.h"
 #include "mozcontainer.h"
 
 #include "prmem.h"
 #include "prlink.h"
 
 #include "nsFilePicker.h"
+#include "nsKDEUtils.h"
 
 #if (MOZ_PLATFORM_MAEMO == 5)
 #include <hildon-fm-2/hildon/hildon-file-chooser-dialog.h>
 #endif
 
 using namespace mozilla;
 
 #define MAX_PREVIEW_SIZE 180
@@ -285,17 +287,19 @@ nsFilePicker::AppendFilters(PRInt32 aFil
   return nsBaseFilePicker::AppendFilters(aFilterMask);
 }
 
 NS_IMETHODIMP
 nsFilePicker::AppendFilter(const nsAString& aTitle, const nsAString& aFilter)
 {
   if (aFilter.EqualsLiteral("..apps")) {
     // No platform specific thing we can do here, really....
-    return NS_OK;
+    // Unless it's KDE.
+    if( mMode != modeOpen || !nsKDEUtils::kdeSupport())
+        return NS_OK;
   }
 
   nsCAutoString filter, name;
   CopyUTF16toUTF8(aFilter, filter);
   CopyUTF16toUTF8(aTitle, name);
 
   mFilters.AppendElement(filter);
   mFilterNames.AppendElement(name);
@@ -388,16 +392,19 @@ nsFilePicker::GetFiles(nsISimpleEnumerat
   }
 
   return NS_ERROR_FAILURE;
 }
 
 NS_IMETHODIMP
 nsFilePicker::Show(PRInt16 *aReturn)
 {
+  if( nsKDEUtils::kdeSupport())
+      return kdeFileDialog( aReturn );
+
   NS_ENSURE_ARG_POINTER(aReturn);
 
   nsXPIDLCString title;
   title.Adopt(ToNewUTF8String(mTitle));
 
   GtkWindow *parent_widget = get_gtk_window_for_nsiwidget(mParentWidget);
 
   GtkFileChooserAction action = GetGtkFileChooserAction(mMode);
@@ -538,8 +545,234 @@ nsFilePicker::Show(PRInt16 *aReturn)
     *aReturn = nsIFilePicker::returnCancel;
     break;
   }
 
   gtk_widget_destroy(file_chooser);
 
   return NS_OK;
 }
+
+nsCString nsFilePicker::kdeMakeFilter( int index )
+    {
+    nsCString buf = mFilters[ index ];
+    for( PRUint32 i = 0;
+         i < buf.Length();
+         ++i )
+        if( buf[ i ] == ';' ) // KDE separates just using spaces
+            buf.SetCharAt( ' ', i );
+    if (!mFilterNames[index].IsEmpty())
+        {
+        buf += "|";
+        buf += mFilterNames[index].get();
+        }
+    return buf;
+    }
+
+static PRInt32 windowToXid( nsIWidget* widget )
+    {
+    GtkWindow *parent_widget = get_gtk_window_for_nsiwidget( widget );
+    GdkWindow* gdk_window = gtk_widget_get_window( gtk_widget_get_toplevel( GTK_WIDGET( parent_widget )));
+    return GDK_WINDOW_XID( gdk_window );
+    }
+
+NS_IMETHODIMP nsFilePicker::kdeFileDialog(PRInt16 *aReturn)
+    {
+    NS_ENSURE_ARG_POINTER(aReturn);
+
+    if( mMode == modeOpen && mFilters.Length() == 1 && mFilters[ 0 ].EqualsLiteral( "..apps" ))
+        return kdeAppsDialog( aReturn );
+
+    nsXPIDLCString title;
+    title.Adopt(ToNewUTF8String(mTitle));
+
+    const char* arg = NULL;
+    if( mAllowURLs )
+        {
+        switch( mMode )
+            {
+            case nsIFilePicker::modeOpen:
+            case nsIFilePicker::modeOpenMultiple:
+                arg = "GETOPENURL";
+                break;
+            case nsIFilePicker::modeSave:
+                arg = "GETSAVEURL";
+                break;
+            case nsIFilePicker::modeGetFolder:
+                arg = "GETDIRECTORYURL";
+                break;
+            }
+        }
+    else
+        {
+        switch( mMode )
+            {
+            case nsIFilePicker::modeOpen:
+            case nsIFilePicker::modeOpenMultiple:
+                arg = "GETOPENFILENAME";
+                break;
+            case nsIFilePicker::modeSave:
+                arg = "GETSAVEFILENAME";
+                break;
+            case nsIFilePicker::modeGetFolder:
+                arg = "GETDIRECTORYFILENAME";
+                break;
+            }
+        }
+
+  nsCAutoString directory;
+  if (mDisplayDirectory) {
+    mDisplayDirectory->GetNativePath(directory);
+  } else if (mPrevDisplayDirectory) {
+    mPrevDisplayDirectory->GetNativePath(directory);
+  }
+
+    nsCAutoString startdir;
+  if (!directory.IsEmpty()) {
+    startdir = directory;
+  }
+  if (mMode == nsIFilePicker::modeSave) {
+    if( !startdir.IsEmpty())
+      {
+      startdir += "/";
+      startdir += ToNewUTF8String(mDefault);
+      }
+    else
+      startdir = ToNewUTF8String(mDefault);
+  }
+  if( startdir.IsEmpty())
+      startdir = ".";
+
+    nsCAutoString filters;
+    PRInt32 count = mFilters.Length();
+    if( count == 0 ) //just in case
+        filters = "*";
+    else
+        {
+        filters = kdeMakeFilter( 0 );
+        for (PRInt32 i = 1; i < count; ++i)
+            {
+            filters += "\n";
+            filters += kdeMakeFilter( i );
+            }
+        }
+
+    nsTArray<nsCString> command;
+    command.AppendElement( nsCAutoString( arg ));
+    command.AppendElement( startdir );
+    if( mMode != nsIFilePicker::modeGetFolder )
+        {
+        command.AppendElement( filters );
+        nsCAutoString selected;
+        selected.AppendInt( mSelectedType );
+        command.AppendElement( selected );
+        }
+    command.AppendElement( title );
+    if( mMode == nsIFilePicker::modeOpenMultiple )
+        command.AppendElement( NS_LITERAL_CSTRING( "MULTIPLE" ));
+    if( PRInt32 xid = windowToXid( mParentWidget ))
+        {
+        command.AppendElement( NS_LITERAL_CSTRING( "PARENT" ));
+        nsCAutoString parent;
+        parent.AppendInt( xid );
+        command.AppendElement( parent );
+        }
+
+    nsTArray<nsCString> output;
+    if( nsKDEUtils::commandBlockUi( command, get_gtk_window_for_nsiwidget( mParentWidget ), &output ))
+        {
+        *aReturn = nsIFilePicker::returnOK;
+        mFiles.Clear();
+        if( mMode != nsIFilePicker::modeGetFolder )
+            {
+            mSelectedType = atoi( output[ 0 ].get());
+            output.RemoveElementAt( 0 );
+            }
+        if (mMode == nsIFilePicker::modeOpenMultiple)
+            {
+            mFileURL.Truncate();
+            PRUint32 count = output.Length();
+            for( PRUint32 i = 0;
+                 i < count;
+                 ++i )
+                {
+                nsCOMPtr<nsILocalFile> localfile;
+                nsresult rv = NS_NewNativeLocalFile( output[ i ],
+                                      PR_FALSE,
+                                      getter_AddRefs(localfile));
+                if (NS_SUCCEEDED(rv))
+                    mFiles.AppendObject(localfile);
+                }
+            }
+        else
+            {
+            if( output.Length() == 0 )
+                mFileURL = nsCString();
+            else if( mAllowURLs )
+                mFileURL = output[ 0 ];
+            else // GetFile() actually requires it to be url even for local files :-/
+                {
+                mFileURL = nsCString( "file://" );
+                mFileURL.Append( output[ 0 ] );
+                }
+            }
+  // Remember last used directory.
+  nsCOMPtr<nsILocalFile> file;
+  GetFile(getter_AddRefs(file));
+  if (file) {
+    nsCOMPtr<nsIFile> dir;
+    file->GetParent(getter_AddRefs(dir));
+    nsCOMPtr<nsILocalFile> localDir(do_QueryInterface(dir));
+    if (localDir) {
+      localDir.swap(mPrevDisplayDirectory);
+    }
+  }
+        if (mMode == nsIFilePicker::modeSave)
+            {
+            nsCOMPtr<nsILocalFile> file;
+            GetFile(getter_AddRefs(file));
+            if (file)
+                {
+                bool exists = PR_FALSE;
+                file->Exists(&exists);
+                if (exists) // TODO do overwrite check in the helper app
+                    *aReturn = nsIFilePicker::returnReplace;
+                }
+            }
+        }
+    else
+        {
+        *aReturn = nsIFilePicker::returnCancel;
+        }
+    return NS_OK;
+    }
+
+
+NS_IMETHODIMP nsFilePicker::kdeAppsDialog(PRInt16 *aReturn)
+    {
+    NS_ENSURE_ARG_POINTER(aReturn);
+
+    nsXPIDLCString title;
+    title.Adopt(ToNewUTF8String(mTitle));
+
+    nsTArray<nsCString> command;
+    command.AppendElement( NS_LITERAL_CSTRING( "APPSDIALOG" ));
+    command.AppendElement( title );
+    if( PRInt32 xid = windowToXid( mParentWidget ))
+        {
+        command.AppendElement( NS_LITERAL_CSTRING( "PARENT" ));
+        nsCAutoString parent;
+        parent.AppendInt( xid );
+        command.AppendElement( parent );
+        }
+
+    nsTArray<nsCString> output;
+    if( nsKDEUtils::commandBlockUi( command, get_gtk_window_for_nsiwidget( mParentWidget ), &output ))
+        {
+        *aReturn = nsIFilePicker::returnOK;
+        mFileURL = output.Length() > 0 ? output[ 0 ] : nsCString();
+        }
+    else
+        {
+        *aReturn = nsIFilePicker::returnCancel;
+        }
+    return NS_OK;
+    }
diff --git a/widget/gtk2/nsFilePicker.h b/widget/gtk2/nsFilePicker.h
--- a/widget/gtk2/nsFilePicker.h
+++ b/widget/gtk2/nsFilePicker.h
@@ -89,11 +89,17 @@ protected:
   nsString  mDefault;
   nsString  mDefaultExtension;
 
   nsTArray<nsCString> mFilters;
   nsTArray<nsCString> mFilterNames;
 
 private:
   static nsILocalFile *mPrevDisplayDirectory;
+
+  bool kdeRunning();
+  bool getKdeRunning();
+  NS_IMETHODIMP kdeFileDialog(PRInt16 *aReturn);
+  NS_IMETHODIMP kdeAppsDialog(PRInt16 *aReturn);
+  nsCString kdeMakeFilter( int index );
 };
 
 #endif
diff --git a/xpcom/components/Makefile.in b/xpcom/components/Makefile.in
--- a/xpcom/components/Makefile.in
+++ b/xpcom/components/Makefile.in
@@ -92,10 +92,11 @@ LOCAL_INCLUDES	= \
 # we don't want the shared lib, but we want to force the creation of a static lib.
 FORCE_STATIC_LIB = 1
 
 include $(topsrcdir)/config/rules.mk
 
 DEFINES	+= -D_IMPL_NS_COM
 
 ifneq (,$(filter gtk2,$(MOZ_WIDGET_TOOLKIT)))
+LOCAL_INCLUDES += -I$(topsrcdir)/toolkit/xre
 CXXFLAGS += $(MOZ_GTK2_CFLAGS)
 endif
diff --git a/xpcom/components/ManifestParser.cpp b/xpcom/components/ManifestParser.cpp
--- a/xpcom/components/ManifestParser.cpp
+++ b/xpcom/components/ManifestParser.cpp
@@ -62,16 +62,17 @@
 #include "nsTextFormatter.h"
 #include "nsVersionComparator.h"
 #include "nsXPCOMCIDInternal.h"
 
 #include "nsIConsoleService.h"
 #include "nsIScriptError.h"
 #include "nsIXULAppInfo.h"
 #include "nsIXULRuntime.h"
+#include "nsKDEUtils.h"
 
 using namespace mozilla;
 
 struct ManifestDirective
 {
   const char* directive;
   int argc;
 
@@ -432,16 +433,17 @@ ParseManifest(NSLocationType type, FileL
   NS_NAMED_LITERAL_STRING(kAppVersion, "appversion");
   NS_NAMED_LITERAL_STRING(kGeckoVersion, "platformversion");
   NS_NAMED_LITERAL_STRING(kOs, "os");
   NS_NAMED_LITERAL_STRING(kOsVersion, "osversion");
   NS_NAMED_LITERAL_STRING(kABI, "abi");
 #if defined(MOZ_WIDGET_ANDROID)
   NS_NAMED_LITERAL_STRING(kTablet, "tablet");
 #endif
+  NS_NAMED_LITERAL_STRING(kDesktop, "desktop");
 
   // Obsolete
   NS_NAMED_LITERAL_STRING(kXPCNativeWrappers, "xpcnativewrappers");
 
   nsAutoString appID;
   nsAutoString appVersion;
   nsAutoString geckoVersion;
   nsAutoString osTarget;
@@ -476,41 +478,46 @@ ParseManifest(NSLocationType type, FileL
         CopyUTF8toUTF16(s, abi);
         abi.Insert(PRUnichar('_'), 0);
         abi.Insert(osTarget, 0);
       }
     }
   }
 
   nsAutoString osVersion;
+  nsAutoString desktop;
 #if defined(XP_WIN)
   OSVERSIONINFO info = { sizeof(OSVERSIONINFO) };
   if (GetVersionEx(&info)) {
     nsTextFormatter::ssprintf(osVersion, NS_LITERAL_STRING("%ld.%ld").get(),
                                          info.dwMajorVersion,
                                          info.dwMinorVersion);
   }
+  desktop = NS_LITERAL_STRING("win");
 #elif defined(MOZ_WIDGET_COCOA)
   SInt32 majorVersion, minorVersion;
   if ((Gestalt(gestaltSystemVersionMajor, &majorVersion) == noErr) &&
       (Gestalt(gestaltSystemVersionMinor, &minorVersion) == noErr)) {
     nsTextFormatter::ssprintf(osVersion, NS_LITERAL_STRING("%ld.%ld").get(),
                                          majorVersion,
                                          minorVersion);
   }
+  desktop = NS_LITERAL_STRING("macosx");
 #elif defined(MOZ_WIDGET_GTK2)
   nsTextFormatter::ssprintf(osVersion, NS_LITERAL_STRING("%ld.%ld").get(),
                                        gtk_major_version,
                                        gtk_minor_version);
+  desktop = nsKDEUtils::kdeSession() ? NS_LITERAL_STRING("kde") : NS_LITERAL_STRING("gnome");
 #elif defined(MOZ_WIDGET_ANDROID)
   bool isTablet = false;
   if (mozilla::AndroidBridge::Bridge()) {
     mozilla::AndroidBridge::Bridge()->GetStaticStringField("android/os/Build$VERSION", "RELEASE", osVersion);
     isTablet = mozilla::AndroidBridge::Bridge()->IsTablet();
   }
+  desktop = NS_LITERAL_STRING("android");
 #endif
 
   // Because contracts must be registered after CIDs, we save and process them
   // at the end.
   nsTArray<CachedDirective> contracts;
 
   char *token;
   char *newline = buf;
@@ -592,24 +599,26 @@ ParseManifest(NSLocationType type, FileL
     TriState stOsVersion = eUnspecified;
     TriState stOs = eUnspecified;
     TriState stABI = eUnspecified;
 #if defined(MOZ_WIDGET_ANDROID)
     TriState stTablet = eUnspecified;
 #endif
     bool platform = false;
     bool contentAccessible = false;
+    TriState stDesktop = eUnspecified;
 
     while (NULL != (token = nsCRT::strtok(whitespace, kWhitespace, &whitespace)) && ok) {
       ToLowerCase(token);
       NS_ConvertASCIItoUTF16 wtoken(token);
 
       if (CheckStringFlag(kApplication, wtoken, appID, stApp) ||
           CheckStringFlag(kOs, wtoken, osTarget, stOs) ||
           CheckStringFlag(kABI, wtoken, abi, stABI) ||
+          CheckStringFlag(kDesktop, wtoken, desktop, stDesktop) ||
           CheckVersionFlag(kOsVersion, wtoken, osVersion, stOsVersion) ||
           CheckVersionFlag(kAppVersion, wtoken, appVersion, stAppVersion) ||
           CheckVersionFlag(kGeckoVersion, wtoken, geckoVersion, stGeckoVersion))
         continue;
 
 #if defined(MOZ_WIDGET_ANDROID)
       bool tablet = false;
       if (CheckFlag(kTablet, wtoken, tablet)) {
@@ -638,16 +647,17 @@ ParseManifest(NSLocationType type, FileL
     }
 
     if (!ok ||
         stApp == eBad ||
         stAppVersion == eBad ||
         stGeckoVersion == eBad ||
         stOs == eBad ||
         stOsVersion == eBad ||
+        stDesktop == eBad ||
 #ifdef MOZ_WIDGET_ANDROID
         stTablet == eBad ||
 #endif
         stABI == eBad)
       continue;
 
     if (directive->regfunc) {
       if (GeckoProcessType_Default != XRE_GetProcessType())
diff --git a/xpcom/io/Makefile.in b/xpcom/io/Makefile.in
--- a/xpcom/io/Makefile.in
+++ b/xpcom/io/Makefile.in
@@ -188,17 +188,17 @@ include $(topsrcdir)/ipc/chromium/chromi
 DEFINES		+= -D_IMPL_NS_COM
 
 ifeq ($(OS_ARCH),Linux)
 ifneq (,$(findstring lib64,$(libdir)))
 DEFINES     += -DHAVE_USR_LIB64_DIR
 endif
 endif
 
-LOCAL_INCLUDES	+= -I..
+LOCAL_INCLUDES	+= -I.. -I$(topsrcdir)/toolkit/xre
 
 ifeq ($(MOZ_PLATFORM_MAEMO),5)
 CFLAGS          += $(MOZ_DBUS_CFLAGS)
 CXXFLAGS        += $(MOZ_DBUS_CFLAGS)
 endif
 
 ifdef MOZ_PLATFORM_MAEMO
 CFLAGS          += $(MOZ_PLATFORM_MAEMO_CFLAGS) $(MOZ_QT_CFLAGS)
diff --git a/xpcom/io/nsLocalFileUnix.cpp b/xpcom/io/nsLocalFileUnix.cpp
--- a/xpcom/io/nsLocalFileUnix.cpp
+++ b/xpcom/io/nsLocalFileUnix.cpp
@@ -90,16 +90,17 @@
 #include "prproces.h"
 #include "nsIDirectoryEnumerator.h"
 #include "nsISimpleEnumerator.h"
 #include "private/pprio.h"
 
 #ifdef MOZ_WIDGET_GTK2
 #include "nsIGIOService.h"
 #include "nsIGnomeVFSService.h"
+#include "nsKDEUtils.h"
 #endif
 
 #ifdef MOZ_WIDGET_COCOA
 #include <Carbon/Carbon.h>
 #include "CocoaFileUtils.h"
 #include "prmem.h"
 #include "plbase64.h"
 
@@ -1795,44 +1796,50 @@ nsLocalFile::SetPersistentDescriptor(con
     return InitWithNativePath(aPersistentDescriptor);
 #endif
 }
 
 NS_IMETHODIMP
 nsLocalFile::Reveal()
 {
 #ifdef MOZ_WIDGET_GTK2
-    nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
-    nsCOMPtr<nsIGnomeVFSService> gnomevfs = do_GetService(NS_GNOMEVFSSERVICE_CONTRACTID);
-    if (!giovfs && !gnomevfs)
-        return NS_ERROR_FAILURE;
-
+    nsCAutoString url;
     bool isDirectory;
     if (NS_FAILED(IsDirectory(&isDirectory)))
         return NS_ERROR_FAILURE;
 
     if (isDirectory) {
-        if (giovfs)
-            return giovfs->ShowURIForInput(mPath);
-        else 
-            /* Fallback to GnomeVFS */
-            return gnomevfs->ShowURIForInput(mPath);
+        url = mPath;
     } else {
         nsCOMPtr<nsIFile> parentDir;
         nsCAutoString dirPath;
         if (NS_FAILED(GetParent(getter_AddRefs(parentDir))))
             return NS_ERROR_FAILURE;
         if (NS_FAILED(parentDir->GetNativePath(dirPath)))
             return NS_ERROR_FAILURE;
 
-        if (giovfs)
-            return giovfs->ShowURIForInput(dirPath);
-        else 
-            return gnomevfs->ShowURIForInput(dirPath);        
+        url = dirPath;        
     }
+
+    if(nsKDEUtils::kdeSupport()) {
+        nsTArray<nsCString> command;
+        command.AppendElement( NS_LITERAL_CSTRING( "OPEN" ));
+        command.AppendElement( url );
+        return nsKDEUtils::command( command ) ? NS_OK : NS_ERROR_FAILURE;
+    }
+
+    nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
+    nsCOMPtr<nsIGnomeVFSService> gnomevfs = do_GetService(NS_GNOMEVFSSERVICE_CONTRACTID);
+    if (!giovfs && !gnomevfs)
+        return NS_ERROR_FAILURE;
+
+    if (giovfs)
+        return giovfs->ShowURIForInput(url);
+    else
+        return gnomevfs->ShowURIForInput(url);
 #elif defined(MOZ_WIDGET_COCOA)
     CFURLRef url;
     if (NS_SUCCEEDED(GetCFURL(&url))) {
       nsresult rv = CocoaFileUtils::RevealFileInFinder(url);
       ::CFRelease(url);
       return rv;
     }
     return NS_ERROR_FAILURE;
@@ -1858,16 +1865,23 @@ nsLocalFile::Launch()
 
     if (nsnull == connection)
       return NS_ERROR_FAILURE;
 
     if (hildon_mime_open_file(connection, mPath.get()) != kHILDON_SUCCESS)
       return NS_ERROR_FAILURE;
     return NS_OK;
 #else
+    if( nsKDEUtils::kdeSupport()) {
+      nsTArray<nsCString> command;
+      command.AppendElement( NS_LITERAL_CSTRING( "OPEN" ));
+      command.AppendElement( mPath );
+      return nsKDEUtils::command( command ) ? NS_OK : NS_ERROR_FAILURE;
+    }
+
     nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
     nsCOMPtr<nsIGnomeVFSService> gnomevfs = do_GetService(NS_GNOMEVFSSERVICE_CONTRACTID);
     if (giovfs) {
       return giovfs->ShowURIForInput(mPath);
     } else if (gnomevfs) {
       /* GnomeVFS fallback */
       return gnomevfs->ShowURIForInput(mPath);
     }

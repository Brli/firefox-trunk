---
 modules/plugin/base/src/ns4xPluginInstance.cpp       |  126 --------------
 modules/plugin/base/src/ns4xPluginInstance.h         |   12 -
 modules/plugin/base/src/nsPluginNativeWindowGtk2.cpp |  170 +++++++++++++------
 widget/src/gtkxtbin/gtk2xtbin.c                      |   10 -
 4 files changed, 130 insertions(+), 188 deletions(-)

Index: mozilla/modules/plugin/base/src/ns4xPluginInstance.cpp
===================================================================
--- mozilla.orig/modules/plugin/base/src/ns4xPluginInstance.cpp	2007-08-15 16:00:45.000000000 +0000
+++ mozilla/modules/plugin/base/src/ns4xPluginInstance.cpp	2007-08-15 16:02:42.000000000 +0000
@@ -54,22 +54,16 @@
 #include "nsIDocument.h"
 
 #include "nsJSNPRuntime.h"
 
 #ifdef XP_OS2
 #include "nsILegacyPluginWrapperOS2.h"
 #endif
 
-#ifdef MOZ_WIDGET_GTK2
-#include <gdk/gdk.h>
-#include <gdk/gdkx.h>
-#include "gtk2xtbin.h"
-#endif
-
 ////////////////////////////////////////////////////////////////////////
 // CID's && IID's
 static NS_DEFINE_IID(kCPluginManagerCID, NS_PLUGINMANAGER_CID); // needed for NS_TRY_SAFE_CALL
 static NS_DEFINE_IID(kIPluginStreamListenerIID, NS_IPLUGINSTREAMLISTENER_IID);
 
 ///////////////////////////////////////////////////////////////////////////////
 // ns4xPluginStreamListener Methods
 
@@ -815,21 +809,16 @@
 }
 
 
 ///////////////////////////////////////////////////////////////////////////////
 ns4xPluginInstance::~ns4xPluginInstance(void)
 {
   PLUGIN_LOG(PLUGIN_LOG_BASIC, ("ns4xPluginInstance dtor: this=%p\n",this));
 
-#if defined (MOZ_WIDGET_GTK2)
-  if (mXtBin)
-    gtk_widget_destroy(mXtBin);
-#endif
-
   // clean the stream list if any
   for(nsInstanceStream *is = mStreams; is != nsnull;) {
     nsInstanceStream * next = is->mNext;
     delete is;
     is = next;
   }
 }
 
@@ -842,19 +831,16 @@
 }
 
 
 ////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP ns4xPluginInstance::Initialize(nsIPluginInstancePeer* peer)
 {
   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("ns4xPluginInstance::Initialize this=%p\n",this));
 
-#if defined (MOZ_WIDGET_GTK2)
-  mXtBin = nsnull;
-#endif
   return InitializePlugin(peer);
 }
 
 ////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP ns4xPluginInstance::GetPeer(nsIPluginInstancePeer* *resultingPeer)
 {
   *resultingPeer = mPeer;
   NS_IF_ADDREF(*resultingPeer);
@@ -885,23 +871,16 @@
   if (mPopupStates.Count() > 0) {
     nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
 
     if (window) {
       window->PopPopupControlState(openAbused);
     }
   }
 
-#if defined (MOZ_WIDGET_GTK2)
-  if (mXtBin) {
-    gtk_widget_destroy(mXtBin);
-    mXtBin = 0;
-  }
-#endif
-
   if(!mStarted)
     return NS_OK;
 
   // Make sure we lock while we're writing to mStarted after we've
   // started as other threads might be checking that inside a lock.
   EnterAsyncPluginThreadCallLock();
   mStarted = PR_FALSE;
   ExitAsyncPluginThreadCallLock();
@@ -1112,119 +1091,22 @@
 NS_IMETHODIMP ns4xPluginInstance::SetWindow(nsPluginWindow* window)
 {
   // XXX 4.x plugins don't want a SetWindow(NULL).
   if (!window || !mStarted)
     return NS_OK;
   
   NPError error;
 
-  // It would be nice if this was all moved to
-  // nsPluginNativeWindowGtk2::CallSetWindow or nsWindow or somewhere else?
 #if defined (MOZ_WIDGET_GTK2)
-  if (window->type == nsPluginWindowType_Window) {
-    PRBool isXembed = PR_FALSE;
-    // bug 108337, flash plugin on linux doesn't like window->width <= 0
-    if ((PRInt32) window->width <= 0 || (PRInt32) window->height <= 0)
-      return NS_OK;
-
-    // We need to test if this is an xembed window before doing checks
-    // below, as they might be used on the first pass or on later passes
-    // when we resize the plugin window.
-    GdkWindow *win = gdk_window_lookup((XID)window->window);
-    if (!win)
-      return NS_ERROR_FAILURE;
-
-    gpointer user_data = nsnull;
-    gdk_window_get_user_data(win, &user_data);
-    if (user_data && GTK_IS_WIDGET(user_data)) {
-      GtkWidget* widget = GTK_WIDGET(user_data);
-
-      if (GTK_IS_SOCKET(widget))
-        isXembed = PR_TRUE;
-    }
-
-    // Fill out the ws_info data.
-    // (ws_info should be non-null but check just in case.)
-    if (!mXtBin && window->ws_info) {
-
-      NPSetWindowCallbackStruct* ws =
-        static_cast<NPSetWindowCallbackStruct*>(window->ws_info);
-
-      if (!isXembed) {  
-#ifdef NS_DEBUG      
-        printf("About to create new xtbin of %i X %i from %p...\n",
-               window->width, window->height, (void*)win);
-#endif
-
-#if 0
-        // if we destroyed the plugin when we left the page, we could remove this
-        // code (i believe) the problem here is that the window gets destroyed when
-        // its parent, etc does by changing a page the plugin instance is being
-        // held on to, so when we return to the page, we have a mXtBin, but it is
-        // in a not-so-good state.
-        // --
-        // this is lame.  we shouldn't be destroying this everytime, but I can't find
-        // a good way to tell if we need to destroy/recreate the xtbin or not
-        // what if the plugin wants to change the window and not just resize it??
-        // (pav)
-
-        if (mXtBin) {
-          gtk_widget_destroy(mXtBin);
-          mXtBin = NULL;
-        }
-#endif
-
-
-        if (!mXtBin) {
-          mXtBin = gtk_xtbin_new(win, 0);
-          // Check to see if creating mXtBin failed for some reason.
-          // if it did, we can't go any further.
-          if (!mXtBin)
-            return NS_ERROR_FAILURE;
-        } 
-
-        gtk_widget_set_usize(mXtBin, window->width, window->height);
-
-#ifdef NS_DEBUG
-        printf("About to show xtbin(%p)...\n", (void*)mXtBin); fflush(NULL);
-#endif
-        gtk_widget_show(mXtBin);
-#ifdef NS_DEBUG
-        printf("completed gtk_widget_show(%p)\n", (void*)mXtBin); fflush(NULL);
-#endif
-      }
-
-      // fill in window info structure 
-      ws->type = 0; // OK, that was a guess!!
-#ifdef MOZ_X11
-      ws->depth = gdk_window_get_visual(win)->depth;
-      if (!isXembed)
-        ws->display = GTK_XTBIN(mXtBin)->xtdisplay;
-      else
-        ws->display = GDK_WINDOW_XDISPLAY(win);
-      ws->visual = GDK_VISUAL_XVISUAL(gdk_window_get_visual(win));
-      ws->colormap = GDK_COLORMAP_XCOLORMAP(gdk_window_get_colormap(win));
-
-      XFlush(ws->display);
-#endif
-    } // !mXtBin
-
-    if (!mXtBin && !isXembed)
-      return NS_ERROR_FAILURE;
-
-    if (!isXembed) {
-      // And now point the NPWindow structures window 
-      // to the actual X window
-      window->window = (nsPluginPort *)GTK_XTBIN(mXtBin)->xtwindow;
-    
-      gtk_xtbin_resize(mXtBin, window->width, window->height);
-    }
+  if (window->type == nsPluginWindowType_Window &&
+      (window->width <= 0 || window->height <= 0)) {
+    // bug 108347, flash plugin on linux doesn't like window->width <= 0
+    return NS_OK;
   }
-  
 #endif // MOZ_WIDGET
 
   if (fCallbacks->setwindow) {
     // XXX Turns out that NPPluginWindow and NPWindow are structurally
     // identical (on purpose!), so there's no need to make a copy.
 
     PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("ns4xPluginInstance::SetWindow (about to call it) this=%p\n",this));
 
Index: mozilla/modules/plugin/base/src/ns4xPluginInstance.h
===================================================================
--- mozilla.orig/modules/plugin/base/src/ns4xPluginInstance.h	2007-08-15 16:00:39.000000000 +0000
+++ mozilla/modules/plugin/base/src/ns4xPluginInstance.h	2007-08-15 16:01:06.000000000 +0000
@@ -58,20 +58,16 @@
 #include "nsIPluginInstanceInternal.h"
 
 #include "npupp.h"
 #ifdef OJI
 #include "jri.h"
 #endif
 #include "prlink.h"  // for PRLibrary
 
-#if defined (MOZ_WIDGET_GTK2)
-#include <gtk/gtk.h>
-#endif
-
 ////////////////////////////////////////////////////////////////////////
 
 class ns4xPluginStreamListener;
 class nsPIDOMWindow;
 
 struct nsInstanceStream
 {
     nsInstanceStream *mNext;
@@ -169,24 +165,16 @@
 
     /**
      * A pointer to the plugin's callback functions. This information
      * is actually stored in the plugin class (<b>nsPluginClass</b>),
      * and is common for all plugins of the class.
      */
     NPPluginFuncs* fCallbacks;
 
-#if defined (MOZ_WIDGET_GTK2)
-   /**
-    * Special GtkXtBin widget that encapsulates the Xt toolkit
-    * within a Gtk Application
-    */
-   GtkWidget *mXtBin;
-#endif
-
     /**
      * The 4.x-style structure used to communicate between the plugin
      * instance and the browser.
      */
     NPP_t fNPP;
 
 #ifdef XP_MACOSX
     NPDrawingModel mDrawingModel;
Index: mozilla/modules/plugin/base/src/nsPluginNativeWindowGtk2.cpp
===================================================================
--- mozilla.orig/modules/plugin/base/src/nsPluginNativeWindowGtk2.cpp	2007-08-15 16:11:44.000000000 +0000
+++ mozilla/modules/plugin/base/src/nsPluginNativeWindowGtk2.cpp	2007-08-15 16:11:59.000000000 +0000
@@ -43,64 +43,69 @@
  */
 
 #include "nsDebug.h"
 #include "nsPluginNativeWindow.h"
 #include "npapi.h"
 #include <gtk/gtk.h>
 #include <gdk/gdkx.h>
 #include <gdk/gdk.h>
+#include "gtk2xtbin.h"
 #ifdef OJI
 #include "plstr.h"
 #include "nsIPlugin.h"
 #include "nsIPluginHost.h"
 
 static NS_DEFINE_CID(kPluginManagerCID, NS_PLUGINMANAGER_CID);
 #endif
 
 class nsPluginNativeWindowGtk2 : public nsPluginNativeWindow {
 public: 
   nsPluginNativeWindowGtk2();
   virtual ~nsPluginNativeWindowGtk2();
 
   virtual nsresult CallSetWindow(nsCOMPtr<nsIPluginInstance> &aPluginInstance);
 private:
-  GtkWidget*  mGtkSocket;
-  NPSetWindowCallbackStruct m_ws_info;
+  NPSetWindowCallbackStruct mWsInfo;
+  /**
+   * Either a GtkSocket or a special GtkXtBin widget (derived from GtkSocket)
+   * that encapsulates the Xt toolkit within a Gtk Application.
+   */
+  GtkWidget* mSocketWidget;
   nsresult  CreateXEmbedWindow();
+  nsresult  CreateXtWindow();
   void      SetAllocation();
   PRBool    CanGetValueFromPlugin(nsCOMPtr<nsIPluginInstance> &aPluginInstance);
 };
 
 static gboolean plug_removed_cb   (GtkWidget *widget, gpointer data);
 
 nsPluginNativeWindowGtk2::nsPluginNativeWindowGtk2() : nsPluginNativeWindow()
 {
   // initialize the struct fields
   window = nsnull; 
   x = 0; 
   y = 0; 
   width = 0; 
   height = 0; 
   memset(&clipRect, 0, sizeof(clipRect));
-  ws_info = &m_ws_info;
+  ws_info = &mWsInfo;
   type = nsPluginWindowType_Window;
-  mGtkSocket = 0;
-  m_ws_info.type = 0;
-  m_ws_info.display = nsnull;
-  m_ws_info.visual = nsnull;
-  m_ws_info.colormap = 0;
-  m_ws_info.depth = 0;
+  mSocketWidget = 0;
+  mWsInfo.type = 0;
+  mWsInfo.display = nsnull;
+  mWsInfo.visual = nsnull;
+  mWsInfo.colormap = 0;
+  mWsInfo.depth = 0;
 }
 
 nsPluginNativeWindowGtk2::~nsPluginNativeWindowGtk2() 
 {
-  if(mGtkSocket) {
-    gtk_widget_destroy(mGtkSocket);
-    mGtkSocket = 0;
+  if(mSocketWidget) {
+    gtk_widget_destroy(mSocketWidget);
   }
 }
 
 nsresult PLUG_NewPluginNativeWindow(nsPluginNativeWindow ** aPluginNativeWindow)
 {
   NS_ENSURE_ARG_POINTER(aPluginNativeWindow);
   *aPluginNativeWindow = new nsPluginNativeWindowGtk2();
   return *aPluginNativeWindow ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
@@ -114,91 +119,152 @@
   return NS_OK;
 }
 
 nsresult nsPluginNativeWindowGtk2::CallSetWindow(nsCOMPtr<nsIPluginInstance> &aPluginInstance)
 {
   if(aPluginInstance) {
     if (type == nsPluginWindowType_Window) {
       nsresult rv;
-      PRBool val = PR_FALSE;
-      if(!mGtkSocket) {
-        if (CanGetValueFromPlugin(aPluginInstance))
+      if(!mSocketWidget) {
+        PRBool needXEmbed = PR_FALSE;
+        if (CanGetValueFromPlugin(aPluginInstance)) {
           rv = aPluginInstance->GetValue
-            ((nsPluginInstanceVariable)NPPVpluginNeedsXEmbed, &val);
-      }
+            ((nsPluginInstanceVariable)NPPVpluginNeedsXEmbed, &needXEmbed);
 #ifdef DEBUG
-      printf("nsPluginNativeWindowGtk2: NPPVpluginNeedsXEmbed=%d\n", val);
+          printf("nsPluginNativeWindowGtk2: NPPVpluginNeedsXEmbed=%d\n", needXEmbed);
 #endif
-      if(val) {
-        CreateXEmbedWindow();
+        }
+        if(needXEmbed) {
+          CreateXEmbedWindow();
+        }
+        else {
+          CreateXtWindow();
+        }
       }
 
-      if(mGtkSocket) {
-        // Make sure to resize and re-place the window if required
+      if(!mSocketWidget)
+        return NS_ERROR_FAILURE;
+
+      // Make sure to resize and re-place the window if required.
+      // Need to reset "window" each time as nsObjectFrame::DidReflow sets it
+      // to the ancestor window.
+      if(GTK_IS_XTBIN(mSocketWidget)) {
+        gtk_xtbin_resize(mSocketWidget, width, height);
+        // Point the NPWindow structures window to the actual X window
+        window = (nsPluginPort *)GTK_XTBIN(mSocketWidget)->xtwindow;
+      }
+      else { // XEmbed
         SetAllocation();
-        window = (nsPluginPort *)gtk_socket_get_id(GTK_SOCKET(mGtkSocket));
+        window = (nsPluginPort *)gtk_socket_get_id(GTK_SOCKET(mSocketWidget));
       }
 #ifdef DEBUG
       printf("nsPluginNativeWindowGtk2: call SetWindow with xid=%p\n", (void *)window);
 #endif
-    }
+    } // nsPluginWindowType_Window
     aPluginInstance->SetWindow(this);
   }
   else if (mPluginInstance)
     mPluginInstance->SetWindow(nsnull);
 
   SetPluginInstance(aPluginInstance);
   return NS_OK;
 }
 
 nsresult nsPluginNativeWindowGtk2::CreateXEmbedWindow() {
-  if(!mGtkSocket) {
-    GdkWindow *win = gdk_window_lookup((XID)window);
-    mGtkSocket = gtk_socket_new();
-
-    //attach the socket to the container widget
-    gtk_widget_set_parent_window(mGtkSocket, win);
-
-    // Make sure to handle the plug_removed signal.  If we don't the
-    // socket will automatically be destroyed when the plug is
-    // removed, which means we're destroying it more than once.
-    // SYNTAX ERROR.
-    g_signal_connect(mGtkSocket, "plug_removed",
-                     G_CALLBACK(plug_removed_cb), NULL);
-
-    gpointer user_data = NULL;
-    gdk_window_get_user_data(win, &user_data);
-
-    GtkContainer *container = GTK_CONTAINER(user_data);
-    gtk_container_add(container, mGtkSocket);
-    gtk_widget_realize(mGtkSocket);
+  NS_ASSERTION(!mSocketWidget,"Already created a socket widget!");
 
-    // Resize before we show
-    SetAllocation();
+  GdkWindow *parent_win = gdk_window_lookup((XID)window);
+  mSocketWidget = gtk_socket_new();
 
-    gtk_widget_show(mGtkSocket);
+  //attach the socket to the container widget
+  gtk_widget_set_parent_window(mSocketWidget, parent_win);
 
-    gdk_flush();
-    window = (nsPluginPort *)gtk_socket_get_id(GTK_SOCKET(mGtkSocket));
-  }
+  // Make sure to handle the plug_removed signal.  If we don't the
+  // socket will automatically be destroyed when the plug is
+  // removed, which means we're destroying it more than once.
+  // SYNTAX ERROR.
+  g_signal_connect(mSocketWidget, "plug_removed",
+                   G_CALLBACK(plug_removed_cb), NULL);
+
+  gpointer user_data = NULL;
+  gdk_window_get_user_data(parent_win, &user_data);
+
+  GtkContainer *container = GTK_CONTAINER(user_data);
+  gtk_container_add(container, mSocketWidget);
+  gtk_widget_realize(mSocketWidget);
+
+  // Resize before we show
+  SetAllocation();
+
+  gtk_widget_show(mSocketWidget);
+
+  gdk_flush();
+  window = (nsPluginPort *)gtk_socket_get_id(GTK_SOCKET(mSocketWidget));
+
+  // Fill out the ws_info structure.
+  // (The windowless case is done in nsObjectFrame.cpp.)
+  GdkWindow *gdkWindow = gdk_window_lookup((XID)window);
+  mWsInfo.display = GDK_WINDOW_XDISPLAY(gdkWindow);
+  mWsInfo.colormap = GDK_COLORMAP_XCOLORMAP(gdk_drawable_get_colormap(gdkWindow));
+  GdkVisual* gdkVisual = gdk_drawable_get_visual(gdkWindow);
+  mWsInfo.visual = GDK_VISUAL_XVISUAL(gdkVisual);
+  mWsInfo.depth = gdkVisual->depth;
 
   return NS_OK;
 }
 
 void nsPluginNativeWindowGtk2::SetAllocation() {
-  if (!mGtkSocket)
+  if (!mSocketWidget)
     return;
 
   GtkAllocation new_allocation;
   new_allocation.x = 0;
   new_allocation.y = 0;
   new_allocation.width = width;
   new_allocation.height = height;
-  gtk_widget_size_allocate(mGtkSocket, &new_allocation);
+  gtk_widget_size_allocate(mSocketWidget, &new_allocation);
+}
+
+nsresult nsPluginNativeWindowGtk2::CreateXtWindow() {
+  NS_ASSERTION(!mSocketWidget,"Already created a socket widget!");
+
+#ifdef NS_DEBUG
+  printf("About to create new xtbin of %i X %i from %p...\n",
+         width, height, (void*)window);
+#endif
+  GdkWindow *gdkWindow = gdk_window_lookup((XID)window);
+  mSocketWidget = gtk_xtbin_new(gdkWindow, 0);
+  // Check to see if creating the xtbin failed for some reason.
+  // if it did, we can't go any further.
+  if (!mSocketWidget)
+    return NS_ERROR_FAILURE;
+
+  gtk_widget_set_size_request(mSocketWidget, width, height);
+
+#ifdef NS_DEBUG
+  printf("About to show xtbin(%p)...\n", (void*)mSocketWidget); fflush(NULL);
+#endif
+  gtk_widget_show(mSocketWidget);
+#ifdef NS_DEBUG
+  printf("completed gtk_widget_show(%p)\n", (void*)mSocketWidget); fflush(NULL);
+#endif
+
+  // Fill out the ws_info structure.
+  GtkXtBin* xtbin = GTK_XTBIN(mSocketWidget);
+  // The xtbin has its own Display structure.
+  mWsInfo.display = xtbin->xtdisplay;
+  mWsInfo.colormap = xtbin->xtclient.xtcolormap;
+  mWsInfo.visual = xtbin->xtclient.xtvisual;
+  mWsInfo.depth = xtbin->xtclient.xtdepth;
+  // Leave mWsInfo.type = 0 - Who knows what this is meant to be?
+
+  XFlush(mWsInfo.display);
+
+  return NS_OK;
 }
 
 PRBool nsPluginNativeWindowGtk2::CanGetValueFromPlugin(nsCOMPtr<nsIPluginInstance> &aPluginInstance)
 {
 #ifdef OJI
   if(aPluginInstance) {
     nsresult rv;
     nsCOMPtr<nsIPluginInstancePeer> peer;
Index: mozilla/widget/src/gtkxtbin/gtk2xtbin.c
===================================================================
--- mozilla.orig/widget/src/gtkxtbin/gtk2xtbin.c	2007-08-15 16:11:49.000000000 +0000
+++ mozilla/widget/src/gtkxtbin/gtk2xtbin.c	2007-08-15 16:11:59.000000000 +0000
@@ -415,21 +415,27 @@
   Arg args[2];
   GtkXtBin *xtbin = GTK_XTBIN (widget);
   GtkAllocation allocation;
 
 #ifdef DEBUG_XTBIN
   printf("gtk_xtbin_resize %p %d %d\n", (void *)widget, width, height);
 #endif
 
+  xtbin->height = height;
+  xtbin->width  = width;
+
+  // Avoid BadValue errors in XtSetValues
+  if (height <= 0 || width <=0) {
+    height = 1;
+    width = 1;
+  }
   XtSetArg(args[0], XtNheight, height);
   XtSetArg(args[1], XtNwidth,  width);
   XtSetValues(xtbin->xtclient.top_widget, args, 2);
-  xtbin->height = height;
-  xtbin->width  = width;
 
   /* we need to send a size allocate so the socket knows about the
      size changes */
   allocation.x = xtbin->x;
   allocation.y = xtbin->y;
   allocation.width = xtbin->width;
   allocation.height = xtbin->height;
 
